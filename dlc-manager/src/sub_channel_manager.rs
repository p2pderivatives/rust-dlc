//! # Module containing a manager enabling set up and update of DLC channels embedded within
//! Lightning Network channels.

use std::{collections::HashMap, marker::PhantomData, ops::Deref, sync::Mutex};

use bitcoin::hashes::Hash;
use bitcoin::{hashes::hex::ToHex, OutPoint, PackedLockTime, Script, Sequence, Transaction, Txid};
use dlc::{channel::sub_channel::LN_GLUE_TX_WEIGHT, PartyParams};
use dlc_messages::{
    channel::{AcceptChannel, OfferChannel},
    oracle_msgs::OracleAnnouncement,
    sub_channel::{
        Reject, SubChannelAccept, SubChannelCloseAccept, SubChannelCloseConfirm,
        SubChannelCloseFinalize, SubChannelCloseOffer, SubChannelConfirm, SubChannelFinalize,
        SubChannelOffer, SubChannelRevoke,
    },
    FundingSignatures, SubChannelMessage,
};
use lightning::{
    chain::chaininterface::FeeEstimator,
    events::{ClosureReason, MessageSendEventsProvider},
    ln::{
        chan_utils::{
            build_commitment_secret, derive_private_key, derive_private_revocation_key,
            CounterpartyCommitmentSecrets,
        },
        channelmanager::ChannelDetails,
        msgs::{ChannelMessageHandler, DecodeError, RevokeAndACK},
        ChannelId,
    },
    sign::{ChannelSigner, SignerProvider},
    util::{
        errors::APIError,
        ser::{Readable, Writeable, Writer},
    },
};
use log::{error, info, trace, warn};
use secp256k1_zkp::{ecdsa::Signature, EcdsaAdaptorSignature, PublicKey, SecretKey};

use crate::{
    chain_monitor::{ChannelInfo, RevokedTxType, TxType},
    channel::{
        generate_temporary_contract_id, offered_channel::OfferedChannel,
        party_points::PartyBasePoints, Channel, ClosedChannel,
    },
    channel_updater::{
        self, FundingInfo, SubChannelSignInfo, SubChannelSignVerifyInfo, SubChannelVerifyInfo,
    },
    contract::{contract_input::ContractInput, ClosedContract, Contract, FundingInputInfo},
    error::Error,
    manager::{get_channel_in_state, get_contract_in_state, Manager, CET_NSEQUENCE},
    subchannel::{
        generate_temporary_dlc_channel_id, AcceptedSubChannel, CloseAcceptedSubChannel,
        CloseConfirmedSubChannel, CloseOfferedSubChannel, ClosingSubChannel, ConfirmedSubChannel,
        LNChainMonitor, LNChannelManager, LnDlcChannelSigner, LnDlcSignerProvider,
        OfferedSubChannel, ReestablishFlag, SignedSubChannel, SubChannel, SubChannelState,
    },
    Blockchain, DlcChannelId, Oracle, Signer, Storage, Time, Wallet,
};

const INITIAL_SPLIT_NUMBER: u64 = (1 << 48) - 1;

/// Returns the sub channel with given id if found and in the expected state. If a peer id is
/// provided also validates the the sub channel is established with it.
macro_rules! get_sub_channel_in_state {
    ($manager: expr, $channel_id: expr, $state: ident, $peer_id: expr) => {{
        match $manager.get_store().get_sub_channel($channel_id)? {
            Some(sub_channel) => match $peer_id as Option<PublicKey> {
                Some(p) if sub_channel.counter_party != p => {
                    Err(Error::InvalidParameters(format!(
                        "Peer {:02x?} is not involved with {} {:02x?}.",
                        $peer_id,
                        stringify!($object_type),
                        $channel_id
                    )))
                }
                _ => {
                    if let SubChannelState::$state(s) = sub_channel.state.clone() {
                        Ok((sub_channel, s))
                    } else {
                        Err(Error::InvalidState(format!(
                            "Expected {} state but got {:?}",
                            stringify!($state),
                            &sub_channel.state,
                        )))
                    }
                }
            },
            None => Err(Error::InvalidParameters(format!(
                "Unknown {} id.",
                stringify!($object_type)
            ))),
        }
    }};
}

pub(crate) use get_sub_channel_in_state;

/// An [`Action`] to be taken by the sub-channel manager after a disconnection with a peer occured.
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(
    feature = "serde",
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "camelCase")
)]
pub enum Action {
    /// The included [`SubChannelOffer`] message should be re-submitted to the peer with included
    /// public key.
    ResendOffer((SubChannelOffer, PublicKey)),
    /// The sub channel with specified `channel_id` should be re-accepted.
    ReAccept {
        #[cfg_attr(
            feature = "serde",
            serde(
                serialize_with = "dlc_messages::serde_utils::serialize_channel_id",
                deserialize_with = "dlc_messages::serde_utils::deserialize_channel_id"
            )
        )]
        /// The id of the sub channel.
        channel_id: ChannelId,
        /// The parameters originally generated by the local node.
        party_params: PartyParams,
        /// The inputs originally selected by the local node.
        funding_inputs_info: Vec<FundingInputInfo>,
        /// The base points originally generated by the local node.
        accept_points: PartyBasePoints,
        /// The public key of the per update seed originally generated by the local node.
        per_update_seed_pk: PublicKey,
    },
    /// The given sub channel should be moved to the signed state as the revoke and ack must have
    /// been given by the peer during the reestablishment of the LN channel.
    ForceSign(
        #[cfg_attr(
            feature = "serde",
            serde(
                serialize_with = "dlc_messages::serde_utils::serialize_channel_id",
                deserialize_with = "dlc_messages::serde_utils::deserialize_channel_id"
            )
        )]
        ChannelId,
    ),
    /// The included [`SubChannelCloseOffer`] message shoud be re-submitted to the peer with
    /// included public key.
    ResendCloseOffer((SubChannelCloseOffer, PublicKey)),
    /// The sub channel with specified `channel_id` should be re-accepted.
    ReAcceptCloseOffer {
        #[cfg_attr(
            feature = "serde",
            serde(
                serialize_with = "dlc_messages::serde_utils::serialize_channel_id",
                deserialize_with = "dlc_messages::serde_utils::deserialize_channel_id"
            )
        )]
        /// The id of the sub channel.
        channel_id: ChannelId,
        /// The balance of the local party in the DLC sub channel for settling it.
        own_balance: u64,
    },
    /// The given [`SubChannelCloseFinalize`] message should be re-sent to the peer with given
    /// `PublicKey`.
    ResendCloseFinalize((SubChannelCloseFinalize, PublicKey)),
}

impl_dlc_writeable_enum!(Action,
    (0, ResendOffer),
    (2, ForceSign),
    (3, ResendCloseOffer),
    (5, ResendCloseFinalize);
    (1, ReAccept, {
        (channel_id, writeable),
        (party_params, { cb_writeable, dlc_messages::ser_impls::party_params::write, dlc_messages::ser_impls::party_params::read }),
        (funding_inputs_info, vec),
        (accept_points, writeable),
        (per_update_seed_pk, writeable)
    }),
    (4, ReAcceptCloseOffer, {
        (channel_id, writeable),
        (own_balance, writeable)
    });;
);

/// Structure enabling management of DLC channels embedded within Lightning Network channels.
pub struct SubChannelManager<
    W: Deref,
    M: Deref,
    C: Deref,
    S: Deref,
    B: Deref,
    O: Deref,
    T: Deref,
    F: Deref,
    D: Deref<Target = Manager<W, B, S, O, T, F>>,
    CS: ChannelSigner,
    SP: Deref,
    LCS: LnDlcChannelSigner,
    K: Deref,
> where
    W::Target: Wallet,
    M::Target: LNChannelManager<K>,
    C::Target: LNChainMonitor,
    S::Target: Storage,
    B::Target: Blockchain,
    O::Target: Oracle,
    T::Target: Time,
    F::Target: FeeEstimator,
    SP::Target: LnDlcSignerProvider<LCS>,
    K::Target: SignerProvider,
{
    ln_channel_manager: M,
    dlc_channel_manager: D,
    actions: Mutex<Vec<Action>>,
    ln_chain_monitor: C,
    phantom_cs: std::marker::PhantomData<CS>,
    signer_provider: SP,
    ln_channel_signers: Mutex<HashMap<ChannelId, LCS>>,
    phantom_k: std::marker::PhantomData<K>,
}

impl<
        W: Deref,
        M: Deref,
        C: Deref,
        S: Deref,
        B: Deref,
        O: Deref,
        T: Deref,
        F: Deref,
        K: Deref,
        D: Deref<Target = Manager<W, B, S, O, T, F>>,
        CS: ChannelSigner,
        SP: Deref,
        LCS: LnDlcChannelSigner,
    > SubChannelManager<W, M, C, S, B, O, T, F, D, CS, SP, LCS, K>
where
    W::Target: Wallet,
    M::Target: LNChannelManager<K>,
    C::Target: LNChainMonitor,
    S::Target: Storage,
    B::Target: Blockchain,
    O::Target: Oracle,
    T::Target: Time,
    F::Target: FeeEstimator,
    K::Target: SignerProvider,
    SP::Target: LnDlcSignerProvider<LCS>,
{
    /// Creates a new [`SubChannelManager`].
    pub fn new(
        ln_channel_manager: M,
        dlc_channel_manager: D,
        ln_chain_monitor: C,
        signer_provider: SP,
    ) -> Result<Self, Error> {
        let actions = dlc_channel_manager.get_store().get_sub_channel_actions()?;
        Ok(Self {
            ln_channel_manager,
            dlc_channel_manager,
            actions: Mutex::new(actions),
            phantom_cs: PhantomData,
            ln_chain_monitor,
            signer_provider,
            ln_channel_signers: Mutex::new(HashMap::new()),
            phantom_k: PhantomData,
        })
    }

    /// Get a reference to the [`Manager`] held by the instance.
    pub fn get_dlc_manager(&self) -> &D {
        &self.dlc_channel_manager
    }

    /// Handles a [`SubChannelMessage`].
    pub fn on_sub_channel_message(
        &self,
        msg: &SubChannelMessage,
        sender: &PublicKey,
    ) -> Result<Option<SubChannelMessage>, Error> {
        match msg {
            SubChannelMessage::Offer(offer) => {
                self.on_subchannel_offer(offer, sender)?;
                Ok(None)
            }
            SubChannelMessage::Accept(a) => {
                let res = self.on_subchannel_accept(a, sender)?;
                Ok(Some(SubChannelMessage::Confirm(res)))
            }
            SubChannelMessage::Confirm(c) => {
                let res = self.on_subchannel_confirm(c, sender)?;
                Ok(Some(SubChannelMessage::Finalize(res)))
            }
            SubChannelMessage::Finalize(f) => {
                let res = self.on_sub_channel_finalize(f, sender)?;
                Ok(Some(SubChannelMessage::Revoke(res)))
            }
            SubChannelMessage::Revoke(r) => {
                self.on_sub_channel_revoke(r, sender)?;
                Ok(None)
            }
            SubChannelMessage::CloseOffer(o) => {
                self.on_sub_channel_close_offer(o, sender)?;
                Ok(None)
            }
            SubChannelMessage::CloseAccept(a) => {
                let res = self.on_sub_channel_close_accept(a, sender)?;
                Ok(Some(SubChannelMessage::CloseConfirm(res)))
            }
            SubChannelMessage::CloseConfirm(c) => {
                let res = self.on_sub_channel_close_confirm(c, sender)?;
                Ok(Some(SubChannelMessage::CloseFinalize(res)))
            }
            SubChannelMessage::CloseFinalize(f) => {
                self.on_sub_channel_close_finalize(f, sender)?;
                Ok(None)
            }
            SubChannelMessage::Reject(r) => {
                self.on_sub_channel_reject(r, sender)?;
                Ok(None)
            }
        }
    }

    /// Validates and stores contract information for a sub channel to be oferred.
    /// Returns a [`SubChannelOffer`] message to be sent to the counter party.
    pub fn offer_sub_channel(
        &self,
        channel_id: ChannelId,
        contract_input: &ContractInput,
        oracle_announcements: &[Vec<OracleAnnouncement>],
    ) -> Result<SubChannelOffer, Error> {
        // TODO(tibo): deal with already split channel
        let channel_details = self
            .ln_channel_manager
            .get_channel_details(&channel_id)
            .ok_or_else(|| {
                Error::InvalidParameters(format!("Unknown LN channel {channel_id:02x?}"))
            })?;

        let sub_channel =
            match self
                .dlc_channel_manager
                .get_store()
                .get_sub_channel(channel_details.channel_id)?
            {
                Some(mut s) => match s.state {
                    SubChannelState::OffChainClosed | SubChannelState::Rejected => {
                        s.is_offer = true;
                        s.update_idx -= 1;

                        // We do this to give older channels a chance to upgrade to the new version which
                        // expects this field to be set to `Some`.
                        s.channel_keys_id = Some(channel_details.channel_keys_id);

                        Some(s)
                    }
                    _ => return Err(Error::InvalidState(
                        "Received sub channel offer but a non closed sub channel already exists"
                            .to_string(),
                    )),
                },
                None => None,
            };

        validate_and_get_ln_values_per_party(
            &channel_details,
            contract_input.offer_collateral,
            contract_input.accept_collateral,
            contract_input.fee_rate,
            true,
        )?;

        let (per_split_seed, update_idx) = match &sub_channel {
            None => (
                self.dlc_channel_manager.get_wallet().get_new_secret_key()?,
                INITIAL_SPLIT_NUMBER,
            ),
            Some(s) => {
                let pub_seed = s.per_split_seed.expect("Should have a per split seed.");
                let sec_seed = self
                    .dlc_channel_manager
                    .get_wallet()
                    .get_secret_key_for_pubkey(&pub_seed)?;
                (sec_seed, s.update_idx)
            }
        };
        let per_split_secret = SecretKey::from_slice(&build_commitment_secret(
            per_split_seed.as_ref(),
            update_idx,
        ))
        .expect("a valid secret key.");

        let next_per_split_point =
            PublicKey::from_secret_key(self.dlc_channel_manager.get_secp(), &per_split_secret);
        let per_split_seed_pk =
            PublicKey::from_secret_key(self.dlc_channel_manager.get_secp(), &per_split_seed);

        let temporary_channel_id = generate_temporary_dlc_channel_id(channel_id, update_idx, 0);

        let (offered_channel, mut offered_contract) = crate::channel_updater::offer_channel(
            self.dlc_channel_manager.get_secp(),
            contract_input,
            &channel_details.counterparty.node_id,
            oracle_announcements,
            crate::manager::CET_NSEQUENCE,
            crate::manager::REFUND_DELAY,
            self.dlc_channel_manager.get_wallet(),
            self.dlc_channel_manager.get_blockchain(),
            self.dlc_channel_manager.get_time(),
            temporary_channel_id,
            true,
            None,
        )?;

        // TODO(tibo): refactor properly.
        offered_contract.offer_params.inputs = Vec::new();
        offered_contract.funding_inputs_info = Vec::new();

        let offered_state = OfferedSubChannel {
            per_split_point: next_per_split_point,
        };

        let sub_channel = match sub_channel {
            Some(mut s) => {
                s.state = SubChannelState::Offered(offered_state);
                s
            }
            None => {
                let party_base_points = crate::utils::get_party_base_points(
                    self.dlc_channel_manager.get_secp(),
                    self.dlc_channel_manager.get_wallet(),
                )?;
                SubChannel {
                    channel_id: channel_details.channel_id,
                    counter_party: channel_details.counterparty.node_id,
                    per_split_seed: Some(per_split_seed_pk),
                    fee_rate_per_vb: contract_input.fee_rate,
                    is_offer: true,
                    update_idx: INITIAL_SPLIT_NUMBER,
                    state: SubChannelState::Offered(offered_state),
                    counter_party_secrets: CounterpartyCommitmentSecrets::new(),
                    own_base_points: party_base_points,
                    counter_base_points: None,
                    fund_value_satoshis: channel_details.channel_value_satoshis,
                    original_funding_redeemscript: channel_details.funding_redeemscript.unwrap(),
                    own_fund_pk: channel_details.holder_funding_pubkey,
                    counter_fund_pk: channel_details.counter_funding_pubkey.ok_or_else(|| {
                        Error::InvalidState("Counter funding PK is missing".to_string())
                    })?,
                    channel_keys_id: Some(channel_details.channel_keys_id),
                }
            }
        };

        let msg = SubChannelOffer {
            channel_id: channel_details.channel_id,
            next_per_split_point,
            revocation_basepoint: sub_channel.own_base_points.revocation_basepoint,
            publish_basepoint: sub_channel.own_base_points.publish_basepoint,
            own_basepoint: sub_channel.own_base_points.own_basepoint,
            channel_own_basepoint: offered_channel.party_points.own_basepoint,
            channel_publish_basepoint: offered_channel.party_points.publish_basepoint,
            channel_revocation_basepoint: offered_channel.party_points.revocation_basepoint,
            contract_info: (&offered_contract).into(),
            channel_first_per_update_point: offered_channel.per_update_point,
            payout_spk: offered_contract.offer_params.payout_script_pubkey.clone(),
            payout_serial_id: offered_contract.offer_params.payout_serial_id,
            offer_collateral: offered_contract.offer_params.collateral,
            cet_locktime: offered_contract.cet_locktime,
            refund_locktime: offered_contract.refund_locktime,
            cet_nsequence: crate::manager::CET_NSEQUENCE,
            fee_rate_per_vbyte: contract_input.fee_rate,
        };

        self.dlc_channel_manager.get_store().upsert_channel(
            Channel::Offered(offered_channel),
            Some(Contract::Offered(offered_contract)),
        )?;
        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;

        Ok(msg)
    }

    /// Accept an offer to establish a sub-channel within the Lightning Network channel identified
    /// by the given [`ChannelId`].
    pub fn accept_sub_channel(
        &self,
        channel_id: &ChannelId,
    ) -> Result<(PublicKey, SubChannelAccept), Error> {
        self.accept_sub_channel_internal(channel_id, None)
    }

    fn accept_sub_channel_internal(
        &self,
        channel_id: &ChannelId,
        params: Option<(
            PartyParams,
            Vec<FundingInputInfo>,
            PartyBasePoints,
            PublicKey,
        )>,
    ) -> Result<(PublicKey, SubChannelAccept), Error> {
        let (mut offered_sub_channel, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            *channel_id,
            Offered,
            None as Option<PublicKey>
        )?;
        let counter_party = offered_sub_channel.counter_party;

        let channel_details = self
            .ln_channel_manager
            .get_channel_details(channel_id)
            .ok_or_else(|| {
                Error::InvalidParameters(format!("Unknown LN channel {channel_id:02x?}"))
            })?;
        let msg = self.ln_channel_manager.with_useable_channel_lock(
            channel_id,
            &counter_party,
            None,
            |channel_lock| {
                let per_split_seed =
                    if let Some(per_split_seed_pk) = offered_sub_channel.per_split_seed {
                        self.dlc_channel_manager
                            .get_wallet()
                            .get_secret_key_for_pubkey(&per_split_seed_pk)?
                    } else {
                        self.dlc_channel_manager.get_wallet().get_new_secret_key()?
                    };
                let per_split_secret = SecretKey::from_slice(&build_commitment_secret(
                    per_split_seed.as_ref(),
                    offered_sub_channel.update_idx,
                ))
                .expect("a valid secret key.");

                offered_sub_channel.per_split_seed = Some(PublicKey::from_secret_key(
                    self.dlc_channel_manager.get_secp(),
                    &per_split_seed,
                ));

                let next_per_split_point = PublicKey::from_secret_key(
                    self.dlc_channel_manager.get_secp(),
                    &per_split_secret,
                );

                let temporary_channel_id =
                    offered_sub_channel
                        .get_dlc_channel_id(0)
                        .ok_or(Error::InvalidParameters(
                            "Could not get dlc channel id".to_string(),
                        ))?;

                let offered_channel = get_channel_in_state!(
                    self.dlc_channel_manager,
                    &temporary_channel_id,
                    Offered,
                    None as Option<PublicKey>
                )?;

                let offered_contract = get_contract_in_state!(
                    self.dlc_channel_manager,
                    &offered_channel.offered_contract_id,
                    Offered,
                    None as Option<PublicKey>
                )?;

                // Revalidate in case channel capacity has changed since receiving the offer.
                let (own_to_self_msat, _) = validate_and_get_ln_values_per_party(
                    &channel_details,
                    offered_contract.total_collateral - offered_contract.offer_params.collateral,
                    offered_contract.offer_params.collateral,
                    offered_contract.fee_rate_per_vb,
                    false,
                )?;

                let funding_redeemscript = channel_details
                    .funding_redeemscript
                    .as_ref()
                    .unwrap()
                    .clone();

                let funding_txo = channel_details
                    .funding_txo
                    .expect("to have a funding tx output");

                let offer_revoke_params = offered_sub_channel
                    .counter_base_points
                    .as_ref()
                    .expect("to have counter base points")
                    .get_revokable_params(
                        self.dlc_channel_manager.get_secp(),
                        &offered_sub_channel.own_base_points.revocation_basepoint,
                        &state.per_split_point,
                    );

                let accept_revoke_params =
                    offered_sub_channel.own_base_points.get_revokable_params(
                        self.dlc_channel_manager.get_secp(),
                        &offered_sub_channel
                            .counter_base_points
                            .as_ref()
                            .expect("to have counter base points")
                            .revocation_basepoint,
                        &next_per_split_point,
                    );

                let own_base_secret_key = self
                    .dlc_channel_manager
                    .get_wallet()
                    .get_secret_key_for_pubkey(
                        &offered_sub_channel.own_base_points.own_basepoint,
                    )?;
                let own_secret_key = derive_private_key(
                    self.dlc_channel_manager.get_secp(),
                    &next_per_split_point,
                    &own_base_secret_key,
                );

                let split_tx = dlc::channel::sub_channel::create_split_tx(
                    &offer_revoke_params,
                    &accept_revoke_params,
                    &OutPoint {
                        txid: funding_txo.txid,
                        vout: funding_txo.index as u32,
                    },
                    channel_details.channel_value_satoshis,
                    offered_contract.total_collateral,
                    offered_contract.fee_rate_per_vb,
                )
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

                let ln_output_value = split_tx.transaction.output[0].value;

                let glue_tx_output_value = ln_output_value
                    - dlc::util::tx_weight_to_fee(
                        LN_GLUE_TX_WEIGHT,
                        offered_contract.fee_rate_per_vb,
                    )
                    .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

                let ln_glue_tx = dlc::channel::sub_channel::create_ln_glue_tx(
                    &OutPoint {
                        txid: split_tx.transaction.txid(),
                        vout: 0,
                    },
                    &funding_redeemscript,
                    PackedLockTime::ZERO,
                    Sequence(crate::manager::CET_NSEQUENCE),
                    glue_tx_output_value,
                );

                let commitment_transactions = self
                    .ln_chain_monitor
                    .get_latest_holder_commitment_txn(&funding_txo)?;

                let (commitment_signed, commit_tx_number) = self
                    .ln_channel_manager
                    .get_updated_funding_outpoint_commitment_signed(
                        channel_lock,
                        &OutPoint {
                            txid: ln_glue_tx.txid(),
                            vout: 0,
                        },
                        glue_tx_output_value,
                        own_to_self_msat,
                    )?;

                let sub_channel_info = SubChannelSignInfo {
                    funding_info: FundingInfo {
                        funding_tx: split_tx.transaction.clone(),
                        funding_script_pubkey: split_tx.output_script.clone(),
                        funding_input_value: split_tx.transaction.output[1].value,
                    },
                    own_adaptor_sk: own_secret_key,
                };

                let (accepted_channel, mut accepted_contract, accept_channel) =
                    channel_updater::accept_channel_offer_internal(
                        self.dlc_channel_manager.get_secp(),
                        &offered_channel,
                        &offered_contract,
                        self.dlc_channel_manager.get_wallet(),
                        self.dlc_channel_manager.get_blockchain(),
                        Some(sub_channel_info),
                        params,
                    )?;

                let ln_glue_signature = dlc::util::get_raw_sig_for_tx_input(
                    self.dlc_channel_manager.get_secp(),
                    &ln_glue_tx,
                    0,
                    &split_tx.output_script,
                    ln_output_value,
                    &own_secret_key,
                )
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

                // TODO(tibo): refactor properly.
                accepted_contract.accept_params.inputs = Vec::new();
                accepted_contract.funding_inputs = Vec::new();

                let msg = SubChannelAccept {
                    channel_id: *channel_id,
                    first_per_split_point: next_per_split_point,
                    revocation_basepoint: offered_sub_channel.own_base_points.revocation_basepoint,
                    publish_basepoint: offered_sub_channel.own_base_points.publish_basepoint,
                    own_basepoint: offered_sub_channel.own_base_points.own_basepoint,
                    commit_signature: commitment_signed.signature,
                    commit_tx_number,
                    htlc_signatures: commitment_signed.htlc_signatures,
                    channel_revocation_basepoint: accept_channel.revocation_basepoint,
                    channel_publish_basepoint: accept_channel.publish_basepoint,
                    channel_own_basepoint: accept_channel.own_basepoint,
                    cet_adaptor_signatures: accept_channel.cet_adaptor_signatures,
                    buffer_adaptor_signature: accept_channel.buffer_adaptor_signature,
                    refund_signature: accept_channel.refund_signature,
                    first_per_update_point: accept_channel.first_per_update_point,
                    payout_spk: accept_channel.payout_spk,
                    payout_serial_id: accept_channel.payout_serial_id,
                    ln_glue_signature,
                };

                self.dlc_channel_manager
                    .get_chain_monitor()
                    .lock()
                    .unwrap()
                    .add_tx(
                        split_tx.transaction.txid(),
                        ChannelInfo {
                            channel_id: offered_sub_channel.channel_id.0,
                            tx_type: TxType::SplitTx,
                        },
                    );

                let accepted_sub_channel = AcceptedSubChannel {
                    offer_per_split_point: state.per_split_point,
                    accept_per_split_point: next_per_split_point,
                    split_tx,
                    ln_glue_transaction: ln_glue_tx,
                    ln_rollback: (&channel_details).into(),
                    commitment_transactions,
                };

                offered_sub_channel.state = SubChannelState::Accepted(accepted_sub_channel);

                self.dlc_channel_manager.get_store().upsert_channel(
                    Channel::Accepted(accepted_channel),
                    Some(Contract::Accepted(accepted_contract)),
                )?;
                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&offered_sub_channel)?;
                self.dlc_channel_manager.get_store().persist_chain_monitor(
                    &self.dlc_channel_manager.get_chain_monitor().lock().unwrap(),
                )?;
                Ok(msg)
            },
        )?;

        Ok((offered_sub_channel.counter_party, msg))
    }

    /// Start force closing the sub channel with given [`ChannelId`].
    pub fn force_close_sub_channel(&self, channel_id: &ChannelId) -> Result<(), Error> {
        let sub_channel = self
            .dlc_channel_manager
            .get_store()
            .get_sub_channel(*channel_id)?
            .ok_or(Error::InvalidParameters(format!(
                "Unknown sub channel {:?}",
                channel_id
            )))?;
        self.force_close_sub_channel_internal(sub_channel)
    }

    fn force_close_sub_channel_internal(&self, mut sub_channel: SubChannel) -> Result<(), Error> {
        match sub_channel.state {
            // Force close by simply asking LDK to force close as the channel funding outpoint has
            // not yet been updated (also updated sub-channel/channel/contract state).
            SubChannelState::Offered(_) => self.force_close_with_ldk(sub_channel)?,
            // Force close by using the saved LN commitment transactions from before the spliting of the
            // channel.
            SubChannelState::Accepted(ref a) => {
                let commitment_transactions = a.commitment_transactions.clone();

                self.force_close_with_saved_commitment(sub_channel, &commitment_transactions)?;
            }
            // Force close by using the saved LN commitment transactions from before the spliting of the
            // channel.
            SubChannelState::Confirmed(ref c) => {
                let commitment_transactions = c.commitment_transactions.clone();
                self.force_close_with_saved_commitment(sub_channel, &commitment_transactions)?;
            }
            // Force close by broadcasting the split transaction and marking the sub-channel as
            // closing, which will trigger the periodic check to watch when the split transaction
            // has enough confirmation to close both the LN channel and DLC channel (through LDK
            // and the `Manager` respectively).
            SubChannelState::Signed(_) | SubChannelState::Finalized(_) => {
                self.force_close_signed_channel(sub_channel, None)?;
            }
            // Same as above, we simply forget that we made an offchain close offer. As we are
            // force closing it is anyway not relevant.
            SubChannelState::CloseOffered(c) => {
                sub_channel.state = SubChannelState::Signed(c.signed_subchannel);
                self.force_close_signed_channel(sub_channel, None)?;
            }
            // The closing mechanism is the same as for the `Signed` state, but we need to rollback
            // the Lightning channel funding outpoint to use the glue transaction so that LDK
            // reacts properly during the closing process.
            SubChannelState::CloseAccepted(c) => {
                self.ln_channel_manager.with_channel_lock_no_check(
                    &sub_channel.channel_id,
                    &sub_channel.counter_party,
                    |channel_lock| {
                        self.ln_channel_manager.set_funding_outpoint(
                            channel_lock,
                            &lightning::chain::transaction::OutPoint {
                                txid: c.signed_subchannel.ln_glue_transaction.txid(),
                                index: 0,
                            },
                            c.ln_rollback.channel_value_satoshis,
                            c.ln_rollback.value_to_self_msat,
                        );
                        Ok(())
                    },
                )?;
                sub_channel.state = SubChannelState::Signed(c.signed_subchannel);
                self.force_close_signed_channel(sub_channel, Some(c.commitment_transactions))?;
            }
            // Once we are in `CloseConfirmed`, we can simply use LDK to close the Lightning
            // channel.
            SubChannelState::CloseConfirmed(_) => {
                self.force_close_with_ldk(sub_channel)?;
            }
            // In these states, either the channel is already closed, or it should be force closed
            // through LDK directly.
            SubChannelState::OnChainClosed
            | SubChannelState::CounterOnChainClosed
            | SubChannelState::OffChainClosed
            | SubChannelState::ClosedPunished(_)
            | SubChannelState::Rejected
            | SubChannelState::Closing(_) => {
                return Err(Error::InvalidParameters(format!(
                    "Tried to force close channel with {:?} state",
                    sub_channel.state,
                )));
            }
        };

        Ok(())
    }

    fn force_close_with_ldk(&self, mut sub_channel: SubChannel) -> Result<(), Error> {
        let dlc_channel_id = sub_channel
            .get_dlc_channel_id(0)
            .expect("to have a channel id in offered state");
        let (closed_channel, closed_contract) =
            self.get_closed_dlc_channel_and_contract(dlc_channel_id, false)?;
        self.ln_channel_manager
            .force_close_channel(&sub_channel.channel_id, &sub_channel.counter_party)?;
        sub_channel.state = SubChannelState::OnChainClosed;
        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;
        self.dlc_channel_manager
            .get_store()
            .upsert_channel(closed_channel, Some(closed_contract))?;
        //TODO(tibo): this is actually unsafe, we shouldn't clean up the chain monitor before
        //having the commitment transaction confirmed on chain.
        let mut chain_monitor = self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
        chain_monitor.cleanup_channel(sub_channel.channel_id.0);
        chain_monitor.cleanup_channel(dlc_channel_id);
        self.dlc_channel_manager
            .get_store()
            .persist_chain_monitor(&chain_monitor)
    }

    fn force_close_with_saved_commitment(
        &self,
        mut sub_channel: SubChannel,
        commitment_transactions: &Vec<Transaction>,
    ) -> Result<(), Error> {
        // The Lightning commitment transaction is always first in the vector so this is safe.
        for tx in commitment_transactions {
            self.dlc_channel_manager
                .get_blockchain()
                .send_transaction(tx)?;
        }

        let dlc_channel_id = sub_channel
            .get_dlc_channel_id(0)
            .expect("to have a channel id in offered state");
        let (closed_channel, closed_contract) =
            self.get_closed_dlc_channel_and_contract(dlc_channel_id, false)?;
        sub_channel.state = SubChannelState::OnChainClosed;
        self.dlc_channel_manager
            .get_store()
            .upsert_channel(closed_channel, Some(closed_contract))?;
        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;
        let mut chain_monitor = self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
        chain_monitor.cleanup_channel(sub_channel.channel_id.0);
        chain_monitor.cleanup_channel(dlc_channel_id);
        self.dlc_channel_manager
            .get_store()
            .persist_chain_monitor(&chain_monitor)?;
        Ok(())
    }

    fn force_close_signed_channel(
        &self,
        mut sub_channel: SubChannel,
        commitment_transactions: Option<Vec<Transaction>>,
    ) -> Result<(), Error> {
        if let SubChannelState::Signed(state) | SubChannelState::Finalized(state) =
            sub_channel.state.clone()
        {
            let publish_base_secret = self
                .dlc_channel_manager
                .get_wallet()
                .get_secret_key_for_pubkey(&sub_channel.own_base_points.publish_basepoint)?;

            let publish_sk = derive_private_key(
                self.dlc_channel_manager.get_secp(),
                &state.own_per_split_point,
                &publish_base_secret,
            );

            let counter_split_signature = state
                .counter_split_adaptor_signature
                .decrypt(&publish_sk)
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

            let mut split_tx = state.split_tx.transaction.clone();

            let own_split_sig = self.get_holder_split_tx_signature(&sub_channel, &split_tx)?;

            dlc::util::finalize_multi_sig_input_transaction(
                &mut split_tx,
                vec![
                    (sub_channel.own_fund_pk, own_split_sig),
                    (sub_channel.counter_fund_pk, counter_split_signature),
                ],
                &sub_channel.original_funding_redeemscript,
                0,
            );

            self.dlc_channel_manager
                .get_blockchain()
                .send_transaction(&split_tx)?;

            let closing_sub_channel = ClosingSubChannel {
                signed_sub_channel: state,
                is_initiator: true,
                commitment_transactions,
            };

            sub_channel.state = SubChannelState::Closing(closing_sub_channel);

            self.dlc_channel_manager
                .get_store()
                .upsert_sub_channel(&sub_channel)?;
        } else {
            unreachable!("Should not call this method if not in Signed or Finalized state");
        }

        Ok(())
    }

    /// Finalize the closing of the sub channel with specified [`ChannelId`].
    fn finalize_force_close_sub_channels(&self, channel_id: &ChannelId) -> Result<(), Error> {
        let (mut closing, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            *channel_id,
            Closing,
            None::<PublicKey>
        )?;

        let split_tx_confs = self
            .dlc_channel_manager
            .get_blockchain()
            .get_transaction_confirmations(&state.signed_sub_channel.split_tx.transaction.txid())?;

        if split_tx_confs < crate::manager::CET_NSEQUENCE {
            return Err(Error::InvalidState(format!(
                "NSequence hasn't elapsed yet, need {} more blocks",
                crate::manager::CET_NSEQUENCE - split_tx_confs
            )));
        }

        let signed_sub_channel = &state.signed_sub_channel;
        let counter_party = closing.counter_party;
        let mut glue_tx = state.signed_sub_channel.ln_glue_transaction.clone();

        if self
            .dlc_channel_manager
            .get_blockchain()
            .get_transaction_confirmations(&glue_tx.txid())
            .unwrap_or(0)
            == 0
        {
            let own_revoke_params = closing.own_base_points.get_revokable_params(
                self.dlc_channel_manager.get_secp(),
                &closing
                    .counter_base_points
                    .as_ref()
                    .expect("to have counter base points")
                    .revocation_basepoint,
                &signed_sub_channel.own_per_split_point,
            );

            let counter_revoke_params = closing
                .counter_base_points
                .as_ref()
                .expect("to have counter base points")
                .get_revokable_params(
                    self.dlc_channel_manager.get_secp(),
                    &closing.own_base_points.revocation_basepoint,
                    &signed_sub_channel.counter_per_split_point,
                );

            let (offer_params, accept_params) = if closing.is_offer {
                (&own_revoke_params, &counter_revoke_params)
            } else {
                (&counter_revoke_params, &own_revoke_params)
            };

            let own_base_secret_key = self
                .dlc_channel_manager
                .get_wallet()
                .get_secret_key_for_pubkey(&closing.own_base_points.own_basepoint)?;
            let own_secret_key = derive_private_key(
                self.dlc_channel_manager.get_secp(),
                &signed_sub_channel.own_per_split_point,
                &own_base_secret_key,
            );

            let own_signature = dlc::util::get_raw_sig_for_tx_input(
                self.dlc_channel_manager.get_secp(),
                &glue_tx,
                0,
                &signed_sub_channel.split_tx.output_script,
                signed_sub_channel.split_tx.transaction.output[0].value,
                &own_secret_key,
            )?;

            dlc::channel::satisfy_buffer_descriptor(
                &mut glue_tx,
                offer_params,
                accept_params,
                &own_revoke_params.own_pk.inner,
                &own_signature,
                &counter_revoke_params.own_pk,
                &signed_sub_channel.counter_glue_signature,
            )?;

            self.dlc_channel_manager
                .get_blockchain()
                .send_transaction(&glue_tx)?;
        }

        let dlc_channel_id = closing.get_dlc_channel_id(0).ok_or(Error::InvalidState(
            "Could not get dlc channel id.".to_string(),
        ))?;

        if let Err(e) = self
            .dlc_channel_manager
            .force_close_sub_channel(&dlc_channel_id, (closing.clone(), &state))
        {
            error!("Error force closing DLC subchannel {}", e);
        }

        if let Some(commitment_transactions) = &state.commitment_transactions {
            for tx in commitment_transactions {
                if let Err(e) = self
                    .dlc_channel_manager
                    .get_blockchain()
                    .send_transaction(tx)
                {
                    error!("Could not broadcast transaction {}: {}", tx.txid(), e);
                }
            }
        } else if let Err(e) = self
            .ln_channel_manager
            .force_close_channel(channel_id, &counter_party)
        {
            error!("Error force closing LN side of channel: {}", e);
        };

        closing.state = if state.is_initiator {
            SubChannelState::OnChainClosed
        } else {
            SubChannelState::CounterOnChainClosed
        };

        let mut chain_monitor = self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
        chain_monitor.cleanup_channel(closing.channel_id.0);
        self.dlc_channel_manager
            .get_store()
            .persist_chain_monitor(&chain_monitor)?;

        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&closing)?;

        Ok(())
    }

    /// Notify that LDK has decided to close the channel with given id. This MUST be called within
    /// the event handler provided to LDK in reaction to the `ChannelClosed` event.
    pub fn notify_ln_channel_closed(
        &self,
        channel_id: ChannelId,
        closure_reason: &ClosureReason,
    ) -> Result<(), Error> {
        let mut sub_channel = self
            .dlc_channel_manager
            .get_store()
            .get_sub_channel(channel_id)?
            .ok_or(Error::InvalidParameters(format!(
                "No channel with id {:?} found",
                channel_id
            )))?;

        let (updated_channel, updated_contract) = match closure_reason {
            ClosureReason::CounterpartyForceClosed { .. }
            | ClosureReason::CommitmentTxConfirmed => match sub_channel.state {
                SubChannelState::Offered(_)
                | SubChannelState::Accepted(_)
                | SubChannelState::Confirmed(_)
                | SubChannelState::CloseAccepted(_)
                | SubChannelState::CloseConfirmed(_)
                | SubChannelState::Finalized(_) => {
                    let dlc_channel_id = sub_channel
                        .get_dlc_channel_id(0)
                        .expect("to have a channel id");
                    let (closed_channel, closed_contract) =
                        self.get_closed_dlc_channel_and_contract(dlc_channel_id, true)?;
                    sub_channel.state = SubChannelState::CounterOnChainClosed;
                    let mut chain_monitor =
                        self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
                    chain_monitor.cleanup_channel(sub_channel.channel_id.0);
                    chain_monitor.cleanup_channel(dlc_channel_id);
                    (Some(closed_channel), Some(closed_contract))
                }
                SubChannelState::OffChainClosed => {
                    let mut chain_monitor =
                        self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
                    chain_monitor.cleanup_channel(sub_channel.channel_id.0);
                    sub_channel.state = SubChannelState::CounterOnChainClosed;
                    (None, None)
                }
                SubChannelState::Signed(_)
                | SubChannelState::Closing(_)
                | SubChannelState::CloseOffered(_)
                | SubChannelState::OnChainClosed
                | SubChannelState::CounterOnChainClosed => {
                    info!("Got notification of LN channel ({}) closure by counter party in state {} where we do not have to react.", channel_id.to_hex(), sub_channel.state);
                    return Ok(());
                }
                SubChannelState::ClosedPunished(_) => {
                    warn!("Got close notification while in ClosedPunished.");
                    return Ok(());
                }
                SubChannelState::Rejected => {
                    info!(
                        "Counterparty closed channel in rejected state, marking as counter closed"
                    );
                    sub_channel.state = SubChannelState::CounterOnChainClosed;
                    (None, None)
                }
            },
            ClosureReason::HolderForceClosed | ClosureReason::ProcessingError { .. } => {
                match sub_channel.state {
                    SubChannelState::Offered(_) | SubChannelState::CloseConfirmed(_) => {
                        let dlc_channel_id = sub_channel
                            .get_dlc_channel_id(0)
                            .expect("to have a channel id");
                        let (closed_channel, closed_contract) =
                            self.get_closed_dlc_channel_and_contract(dlc_channel_id, false)?;
                        sub_channel.state = SubChannelState::OnChainClosed;
                        let mut chain_monitor =
                            self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
                        chain_monitor.cleanup_channel(sub_channel.channel_id.0);
                        chain_monitor.cleanup_channel(dlc_channel_id);
                        (Some(closed_channel), Some(closed_contract))
                    }
                    SubChannelState::OffChainClosed => {
                        let mut chain_monitor =
                            self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
                        chain_monitor.cleanup_channel(sub_channel.channel_id.0);
                        sub_channel.state = SubChannelState::OnChainClosed;
                        (None, None)
                    }
                    SubChannelState::Accepted(_) | SubChannelState::Confirmed(_) => {
                        return self.force_close_sub_channel_internal(sub_channel);
                    }
                    SubChannelState::CloseAccepted(ref c) => {
                        let split_input = &c.signed_subchannel.split_tx.transaction.input[0];
                        let funding_txo = lightning::chain::transaction::OutPoint {
                            txid: split_input.previous_output.txid,
                            index: split_input.previous_output.vout as u16,
                        };
                        self.ln_chain_monitor.update_channel_funding_txo(
                            &funding_txo,
                            &c.ln_rollback.funding_outpoint,
                            c.ln_rollback.channel_value_satoshis,
                        )?;
                        let commitment_transactions = Some(
                            self.ln_chain_monitor
                                .get_latest_holder_commitment_txn(&funding_txo)?,
                        );
                        let mut signed_subchannel = sub_channel.clone();
                        signed_subchannel.state =
                            SubChannelState::Signed(c.signed_subchannel.clone());
                        self.force_close_signed_channel(
                            signed_subchannel,
                            commitment_transactions,
                        )?;
                        return Ok(());
                    }
                    SubChannelState::CloseOffered(ref c) => {
                        let split_input = &c.signed_subchannel.split_tx.transaction.input[0];
                        let funding_txo = lightning::chain::transaction::OutPoint {
                            txid: split_input.previous_output.txid,
                            index: split_input.previous_output.vout as u16,
                        };
                        let commitment_transactions = Some(
                            self.ln_chain_monitor
                                .get_latest_holder_commitment_txn(&funding_txo)?,
                        );
                        let mut signed_subchannel = sub_channel.clone();
                        signed_subchannel.state =
                            SubChannelState::Signed(c.signed_subchannel.clone());
                        self.force_close_signed_channel(
                            signed_subchannel,
                            commitment_transactions,
                        )?;
                        return Ok(());
                    }
                    SubChannelState::Signed(ref s) | SubChannelState::Finalized(ref s) => {
                        let split_input = &s.split_tx.transaction.input[0];
                        let funding_txo = lightning::chain::transaction::OutPoint {
                            txid: split_input.previous_output.txid,
                            index: split_input.previous_output.vout as u16,
                        };
                        let commitment_transactions = Some(
                            self.ln_chain_monitor
                                .get_latest_holder_commitment_txn(&funding_txo)?,
                        );
                        self.force_close_signed_channel(sub_channel, commitment_transactions)?;
                        return Ok(());
                    }
                    _ => return Ok(()),
                }
            }
            ClosureReason::CooperativeClosure => {
                info!("Channel {channel_id:?} was cooperatively closed");
                return Ok(());
            }
            ClosureReason::FundingTimedOut => {
                info!("Channel {channel_id:?} timed out");
                return Ok(());
            }
            ClosureReason::DisconnectedPeer => {
                info!("Channel {channel_id:?} closed due to disconnected peer before funding completed.");
                return Ok(());
            }
            ClosureReason::OutdatedChannelManager => {
                info!("Channel {channel_id:?} closed due to outdated channel manager.");
                return Ok(());
            }
            ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                info!(
                    "Channel {channel_id:?} closed due to counter party closing unfunded channel."
                );
                return Ok(());
            }
            ClosureReason::FundingBatchClosure => {
                info!("Channel {channel_id:?} closed due to funding batch closure.");
                return Ok(());
            }
        };

        if let Some(channel) = updated_channel {
            self.dlc_channel_manager
                .get_store()
                .upsert_channel(channel, updated_contract)?;
        }

        let chain_monitor = self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
        self.dlc_channel_manager
            .get_store()
            .persist_chain_monitor(&chain_monitor)?;
        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;

        Ok(())
    }

    /// Generates an offer to collaboratively close a sub channel off chain, updating its state.
    pub fn offer_subchannel_close(
        &self,
        channel_id: &ChannelId,
        accept_balance: u64,
    ) -> Result<(SubChannelCloseOffer, PublicKey), Error> {
        let (mut signed_subchannel, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            *channel_id,
            Signed,
            None::<PublicKey>
        )?;

        let dlc_channel_id = signed_subchannel
            .get_dlc_channel_id(0)
            .ok_or(Error::InvalidState(
                "Could not get dlc channel id.".to_string(),
            ))?;

        let dlc_channel = get_channel_in_state!(
            self.dlc_channel_manager,
            &dlc_channel_id,
            Signed,
            None::<PublicKey>
        )?;

        let offer_balance = match dlc_channel.state {
            crate::channel::signed_channel::SignedChannelState::Established {
                total_collateral,
                ..
            } => {
                if total_collateral < accept_balance {
                    return Err(Error::InvalidParameters(
                        "Accept balance must be smaller than total collateral in DLC channel."
                            .to_string(),
                    ));
                }

                total_collateral - accept_balance
            }
            crate::channel::signed_channel::SignedChannelState::Settled {
                counter_payout,
                own_payout,
                ..
            } => {
                if accept_balance != counter_payout {
                    return Err(Error::InvalidParameters("Accept balance must be equal to the counter payout when DLC channel is settled.".to_string()));
                }

                own_payout
            }
            _ => {
                return Err(Error::InvalidState(
                    "Can only close subchannel that are established or settled".to_string(),
                ));
            }
        };

        let close_offer = SubChannelCloseOffer {
            channel_id: *channel_id,
            accept_balance,
        };

        let counter_party = signed_subchannel.counter_party;
        let close_offered_subchannel = CloseOfferedSubChannel {
            signed_subchannel: state,
            offer_balance,
            accept_balance,
            is_offer: true,
        };

        signed_subchannel.state = SubChannelState::CloseOffered(close_offered_subchannel);

        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&signed_subchannel)?;

        Ok((close_offer, counter_party))
    }

    /// Accept an offer to collaboratively close a sub channel off chain, updating its state.
    pub fn accept_subchannel_close_offer(
        &self,
        channel_id: &ChannelId,
    ) -> Result<(SubChannelCloseAccept, PublicKey), Error> {
        let (mut sub_channel, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            *channel_id,
            CloseOffered,
            None::<PublicKey>
        )?;

        if state.is_offer {
            return Err(Error::InvalidParameters(
                "Cannot accept own offer".to_string(),
            ));
        }

        let channel_details = self
            .ln_channel_manager
            .get_channel_details(channel_id)
            .ok_or_else(|| Error::InvalidParameters(format!("Unknown channel {channel_id:?}")))?;

        let ((commitment_signed, commit_tx_number), commitment_transactions) =
            self.ln_channel_manager.with_useable_channel_lock(
                channel_id,
                &sub_channel.counter_party,
                None,
                |channel_lock| {
                    let dlc_channel_id =
                        sub_channel
                            .get_dlc_channel_id(0)
                            .ok_or(Error::InvalidState(
                                "Could not get dlc channel id.".to_string(),
                            ))?;

                    let dlc_channel = get_channel_in_state!(
                        self.dlc_channel_manager,
                        &dlc_channel_id,
                        Signed,
                        None::<PublicKey>
                    )?;
                    let funding_txo = lightning::chain::transaction::OutPoint {
                        txid: state.signed_subchannel.split_tx.transaction.input[0]
                            .previous_output
                            .txid,
                        index: state.signed_subchannel.split_tx.transaction.input[0]
                            .previous_output
                            .vout as u16,
                    };
                    let commitment_transactions = self
                        .ln_chain_monitor
                        .get_latest_holder_commitment_txn(&funding_txo)?;

                    let total_collateral =
                        dlc_channel.own_params.collateral + dlc_channel.counter_params.collateral;

                    debug_assert_eq!(state.accept_balance + state.offer_balance, total_collateral);

                    let (_, accept_fees) = per_party_fee(sub_channel.fee_rate_per_vb)?;

                    let ln_own_balance_msats = channel_details.outbound_capacity_msat
                        + channel_details.unspendable_punishment_reserve.unwrap() * 1000
                        + accept_fees * 1000
                        + state.accept_balance * 1000;

                    let fund_value = sub_channel.fund_value_satoshis;

                    let commitment_signed = self
                        .ln_channel_manager
                        .get_updated_funding_outpoint_commitment_signed(
                            channel_lock,
                            &state.signed_subchannel.split_tx.transaction.input[0].previous_output,
                            fund_value,
                            ln_own_balance_msats,
                        )?;

                    Ok((commitment_signed, commitment_transactions))
                },
            )?;

        let close_accept = SubChannelCloseAccept {
            channel_id: *channel_id,
            commit_signature: commitment_signed.signature,
            commit_tx_number,
            htlc_signatures: commitment_signed.htlc_signatures,
        };

        let close_accepted_subchannel = CloseAcceptedSubChannel {
            signed_subchannel: state.signed_subchannel,
            own_balance: state.accept_balance,
            counter_balance: state.offer_balance,
            ln_rollback: (&channel_details).into(),
            commitment_transactions,
        };

        sub_channel.state = SubChannelState::CloseAccepted(close_accepted_subchannel);

        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;

        Ok((close_accept, sub_channel.counter_party))
    }

    /// Reject an offer to establish a sub channel.
    pub fn reject_sub_channel_offer(
        &self,
        channel_id: ChannelId,
    ) -> Result<(PublicKey, Reject), Error> {
        let (mut sub_channel, _) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            channel_id,
            Offered,
            None::<PublicKey>
        )?;

        sub_channel.state = SubChannelState::Rejected;

        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;

        Ok((sub_channel.counter_party, Reject { channel_id }))
    }

    /// Reject an offer to collaboratively close a sub channel off chain.
    pub fn reject_sub_channel_close_offer(&self, channel_id: ChannelId) -> Result<Reject, Error> {
        let (mut sub_channel, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            channel_id,
            CloseOffered,
            None::<PublicKey>
        )?;

        sub_channel.state = SubChannelState::Signed(state.signed_subchannel);

        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;

        Ok(Reject { channel_id })
    }

    /// Moves the sub channel to the `[SubChannelState::Signed]` state when a disconnection happens while the peer is waiting for
    /// the revocation message from the remote node (the revocation secret must have been given by the remote node during the
    /// reestablishment protocol).
    fn mark_channel_signed(&self, channel_id: ChannelId) -> Result<(), Error> {
        let (mut signed_sub_channel, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            channel_id,
            Finalized,
            None::<PublicKey>
        )?;

        let dlc_channel_id =
            signed_sub_channel
                .get_dlc_channel_id(0)
                .ok_or(Error::InvalidState(
                    "Could not get dlc channel id".to_string(),
                ))?;
        let channel = get_channel_in_state!(
            self.dlc_channel_manager,
            &dlc_channel_id,
            Signed,
            None::<PublicKey>
        )?;
        let contract = get_contract_in_state!(
            self.dlc_channel_manager,
            &channel
                .get_contract_id()
                .ok_or_else(|| Error::InvalidState(
                    "No contract id in on_sub_channel_finalize".to_string()
                ))?,
            Confirmed,
            None::<PublicKey>
        )?;

        self.dlc_channel_manager.get_store().upsert_channel(
            Channel::Signed(channel),
            Some(Contract::Confirmed(contract)),
        )?;

        signed_sub_channel.state = SubChannelState::Signed(state);

        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&signed_sub_channel)?;

        Ok(())
    }

    fn on_subchannel_offer(
        &self,
        sub_channel_offer: &SubChannelOffer,
        counter_party: &PublicKey,
    ) -> Result<(), Error> {
        let channel_details = self
            .ln_channel_manager
            .get_channel_details(&sub_channel_offer.channel_id)
            .ok_or_else(|| {
                Error::InvalidParameters(format!(
                    "Unknown channel {:02x?}",
                    sub_channel_offer.channel_id
                ))
            })?;

        let sub_channel =
            match self
                .dlc_channel_manager
                .get_store()
                .get_sub_channel(channel_details.channel_id)?
            {
                Some(mut s) => match s.state {
                    SubChannelState::OffChainClosed | SubChannelState::Rejected => {
                        s.is_offer = false;
                        s.update_idx -= 1;
                        Some(s)
                    }
                    _ => return Err(Error::InvalidState(
                        "Received sub channel offer but a non closed sub channel already exists"
                            .to_string(),
                    )),
                },
                None => None,
            };

        validate_and_get_ln_values_per_party(
            &channel_details,
            sub_channel_offer.contract_info.get_total_collateral()
                - sub_channel_offer.offer_collateral,
            sub_channel_offer.offer_collateral,
            sub_channel_offer.fee_rate_per_vbyte,
            false,
        )?;

        // TODO(tibo): validate subchannel is valid wrt current channel conditions.

        let offered_sub_channel = OfferedSubChannel {
            per_split_point: sub_channel_offer.next_per_split_point,
        };

        let sub_channel = match sub_channel {
            Some(mut s) => {
                s.state = SubChannelState::Offered(offered_sub_channel);

                // We do this to give older channels a chance to upgrade to the new version which
                // expects this field to be set to `Some`.
                s.channel_keys_id = Some(channel_details.channel_keys_id);

                s
            }
            None => SubChannel {
                channel_id: channel_details.channel_id,
                counter_party: channel_details.counterparty.node_id,
                per_split_seed: None,
                fee_rate_per_vb: sub_channel_offer.fee_rate_per_vbyte,
                is_offer: false,
                update_idx: INITIAL_SPLIT_NUMBER,
                state: SubChannelState::Offered(offered_sub_channel),
                counter_party_secrets: CounterpartyCommitmentSecrets::new(),
                own_base_points: crate::utils::get_party_base_points(
                    self.dlc_channel_manager.get_secp(),
                    self.dlc_channel_manager.get_wallet(),
                )?,
                counter_base_points: Some(PartyBasePoints {
                    own_basepoint: sub_channel_offer.own_basepoint,
                    revocation_basepoint: sub_channel_offer.revocation_basepoint,
                    publish_basepoint: sub_channel_offer.publish_basepoint,
                }),
                fund_value_satoshis: channel_details.channel_value_satoshis,
                original_funding_redeemscript: channel_details.funding_redeemscript.unwrap(),
                own_fund_pk: channel_details.holder_funding_pubkey,
                counter_fund_pk: channel_details.counter_funding_pubkey.ok_or_else(|| {
                    Error::InvalidState("Counter funding PK is missing".to_string())
                })?,
                channel_keys_id: Some(channel_details.channel_keys_id),
            },
        };

        let temporary_channel_id = generate_temporary_dlc_channel_id(
            channel_details.channel_id,
            sub_channel.update_idx,
            0,
        );

        let temporary_contract_id =
            generate_temporary_contract_id(temporary_channel_id, INITIAL_SPLIT_NUMBER);

        let offer_channel = OfferChannel {
            protocol_version: 0, //unused
            contract_flags: 0,   //unused
            chain_hash: [0; 32], //unused
            temporary_contract_id,
            temporary_channel_id,
            contract_info: sub_channel_offer.contract_info.clone(),
            // THIS IS INCORRECT!!! SHOULD BE KEY FROM SPLIT TX
            funding_pubkey: channel_details.holder_funding_pubkey,
            revocation_basepoint: sub_channel_offer.channel_revocation_basepoint,
            publish_basepoint: sub_channel_offer.channel_publish_basepoint,
            own_basepoint: sub_channel_offer.channel_own_basepoint,
            first_per_update_point: sub_channel_offer.channel_first_per_update_point,
            payout_spk: sub_channel_offer.payout_spk.clone(),
            payout_serial_id: sub_channel_offer.payout_serial_id,
            offer_collateral: sub_channel_offer.offer_collateral,
            funding_inputs: vec![],
            change_spk: Script::default(),
            change_serial_id: 0,
            fund_output_serial_id: 0,
            fee_rate_per_vb: sub_channel_offer.fee_rate_per_vbyte,
            cet_locktime: sub_channel_offer.cet_locktime,
            refund_locktime: sub_channel_offer.refund_locktime,
            cet_nsequence: sub_channel_offer.cet_nsequence,
            reference_id: None,
        };

        let (offered_channel, offered_contract) =
            OfferedChannel::from_offer_channel(&offer_channel, *counter_party)?;

        self.dlc_channel_manager.get_store().upsert_channel(
            Channel::Offered(offered_channel),
            Some(Contract::Offered(offered_contract)),
        )?;
        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;

        Ok(())
    }

    fn on_subchannel_accept(
        &self,
        sub_channel_accept: &SubChannelAccept,
        counter_party: &PublicKey,
    ) -> Result<SubChannelConfirm, Error> {
        let (mut offered_sub_channel, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            sub_channel_accept.channel_id,
            Offered,
            Some(*counter_party)
        )?;

        let channel_details = self
            .ln_channel_manager
            .get_channel_details(&sub_channel_accept.channel_id)
            .ok_or_else(|| {
                Error::InvalidParameters(format!(
                    "Unknown LN channel {:02x?}",
                    sub_channel_accept.channel_id
                ))
            })?;

        let ln_rollback = (&channel_details).into();

        let offer_revoke_params = offered_sub_channel.own_base_points.get_revokable_params(
            self.dlc_channel_manager.get_secp(),
            &sub_channel_accept.revocation_basepoint,
            &state.per_split_point,
        );

        let accept_points = PartyBasePoints {
            own_basepoint: sub_channel_accept.own_basepoint,
            revocation_basepoint: sub_channel_accept.revocation_basepoint,
            publish_basepoint: sub_channel_accept.publish_basepoint,
        };

        let accept_revoke_params = accept_points.get_revokable_params(
            self.dlc_channel_manager.get_secp(),
            &offered_sub_channel.own_base_points.revocation_basepoint,
            &sub_channel_accept.first_per_split_point,
        );

        let funding_txo = channel_details.funding_txo.expect("to have a funding txo");
        let funding_outpoint = OutPoint {
            txid: funding_txo.txid,
            vout: funding_txo.index as u32,
        };
        let funding_redeemscript = channel_details
            .funding_redeemscript
            .as_ref()
            .unwrap()
            .clone();

        let temporary_channel_id =
            offered_sub_channel
                .get_dlc_channel_id(0)
                .ok_or(Error::InvalidParameters(
                    "Could not get dlc channel id".to_string(),
                ))?;

        let offered_channel = get_channel_in_state!(
            self.dlc_channel_manager,
            &temporary_channel_id,
            Offered,
            None as Option<PublicKey>
        )?;

        let offered_contract = get_contract_in_state!(
            self.dlc_channel_manager,
            &offered_channel.offered_contract_id,
            Offered,
            None as Option<PublicKey>
        )?;

        let (own_to_self_value_msat, _) = validate_and_get_ln_values_per_party(
            &channel_details,
            offered_contract.offer_params.collateral,
            offered_contract.total_collateral - offered_contract.offer_params.collateral,
            offered_contract.fee_rate_per_vb,
            true,
        )?;

        let split_tx = dlc::channel::sub_channel::create_split_tx(
            &offer_revoke_params,
            &accept_revoke_params,
            &funding_outpoint,
            channel_details.channel_value_satoshis,
            offered_contract.total_collateral,
            offered_contract.fee_rate_per_vb,
        )?;

        let ln_output_value = split_tx.transaction.output[0].value;

        let channel_id = &channel_details.channel_id;

        let own_base_secret_key = self
            .dlc_channel_manager
            .get_wallet()
            .get_secret_key_for_pubkey(&offered_sub_channel.own_base_points.own_basepoint)?;
        let own_secret_key = derive_private_key(
            self.dlc_channel_manager.get_secp(),
            &state.per_split_point,
            &own_base_secret_key,
        );

        let glue_tx_output_value = ln_output_value
            - dlc::util::tx_weight_to_fee(LN_GLUE_TX_WEIGHT, offered_contract.fee_rate_per_vb)
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

        let ln_glue_tx = dlc::channel::sub_channel::create_ln_glue_tx(
            &OutPoint {
                txid: split_tx.transaction.txid(),
                vout: 0,
            },
            &funding_redeemscript,
            PackedLockTime::ZERO,
            Sequence(crate::manager::CET_NSEQUENCE),
            glue_tx_output_value,
        );

        let (
            split_tx_adaptor_signature,
            (commitment_signed, commit_tx_number),
            revoke_and_ack,
            commitment_transactions,
        ) = self.ln_channel_manager.with_useable_channel_lock(
            channel_id,
            counter_party,
            Some(sub_channel_accept.commit_tx_number),
            |channel_lock| {
                let split_tx_adaptor_signature = self.get_holder_split_tx_adaptor_signature(
                    *channel_id,
                    channel_details.channel_value_satoshis,
                    channel_details.channel_keys_id,
                    &split_tx.transaction,
                    &funding_redeemscript,
                    &accept_revoke_params.publish_pk.inner,
                )?;

                let commitment_transactions = self
                    .ln_chain_monitor
                    .get_latest_holder_commitment_txn(&funding_txo)?;

                let commitment_signed = self
                    .ln_channel_manager
                    .get_updated_funding_outpoint_commitment_signed(
                        channel_lock,
                        &OutPoint {
                            txid: ln_glue_tx.txid(),
                            vout: 0,
                        },
                        glue_tx_output_value,
                        own_to_self_value_msat,
                    )?;
                let revoke_and_ack = self.ln_channel_manager.on_commitment_signed_get_raa(
                    channel_lock,
                    &sub_channel_accept.commit_signature,
                    &sub_channel_accept.htlc_signatures,
                )?;

                Ok((
                    split_tx_adaptor_signature,
                    commitment_signed,
                    revoke_and_ack,
                    commitment_transactions,
                ))
            },
        )?;

        let accept_channel = AcceptChannel {
            temporary_channel_id: offered_channel.temporary_channel_id,
            accept_collateral: offered_contract.total_collateral
                - offered_contract.offer_params.collateral,
            funding_pubkey: channel_details.holder_funding_pubkey,
            revocation_basepoint: sub_channel_accept.channel_revocation_basepoint,
            publish_basepoint: sub_channel_accept.channel_publish_basepoint,
            own_basepoint: sub_channel_accept.channel_own_basepoint,
            first_per_update_point: sub_channel_accept.first_per_update_point,
            payout_serial_id: sub_channel_accept.payout_serial_id,
            funding_inputs: vec![],
            change_spk: Script::default(),
            change_serial_id: 0,
            cet_adaptor_signatures: sub_channel_accept.cet_adaptor_signatures.clone(),
            buffer_adaptor_signature: sub_channel_accept.buffer_adaptor_signature,
            refund_signature: sub_channel_accept.refund_signature,
            negotiation_fields: None,
            payout_spk: sub_channel_accept.payout_spk.clone(),
            reference_id: None,
        };

        let sub_channel_info = SubChannelSignVerifyInfo {
            funding_info: FundingInfo {
                funding_tx: split_tx.transaction.clone(),
                funding_script_pubkey: split_tx.output_script.clone(),
                funding_input_value: split_tx.transaction.output[1].value,
            },
            own_adaptor_sk: own_secret_key,
            counter_adaptor_pk: accept_revoke_params.own_pk.inner,
            sub_channel_id: sub_channel_accept.channel_id,
        };

        let (signed_channel, signed_contract, sign_channel) =
            crate::channel_updater::verify_and_sign_accepted_channel_internal(
                self.dlc_channel_manager.get_secp(),
                &offered_channel,
                &offered_contract,
                &accept_channel,
                //TODO(tibo): this should be parameterizable.
                crate::manager::CET_NSEQUENCE,
                self.dlc_channel_manager.get_wallet(),
                Some(sub_channel_info),
                self.dlc_channel_manager.get_chain_monitor(),
            )?;

        dlc::verify_tx_input_sig(
            self.dlc_channel_manager.get_secp(),
            &sub_channel_accept.ln_glue_signature,
            &ln_glue_tx,
            0,
            &split_tx.output_script,
            ln_output_value,
            &accept_revoke_params.own_pk.inner,
        )?;

        let ln_glue_signature = dlc::util::get_raw_sig_for_tx_input(
            self.dlc_channel_manager.get_secp(),
            &ln_glue_tx,
            0,
            &split_tx.output_script,
            ln_output_value,
            &own_secret_key,
        )?;

        let msg = SubChannelConfirm {
            channel_id: sub_channel_accept.channel_id,
            split_adaptor_signature: split_tx_adaptor_signature,
            commit_signature: commitment_signed.signature,
            commit_tx_number,
            htlc_signatures: commitment_signed.htlc_signatures,
            cet_adaptor_signatures: sign_channel.cet_adaptor_signatures,
            buffer_adaptor_signature: sign_channel.buffer_adaptor_signature,
            refund_signature: sign_channel.refund_signature,
            ln_glue_signature,
        };

        self.dlc_channel_manager
            .get_chain_monitor()
            .lock()
            .unwrap()
            .add_tx(
                split_tx.transaction.txid(),
                ChannelInfo {
                    channel_id: offered_sub_channel.channel_id.0,
                    tx_type: TxType::SplitTx,
                },
            );

        let confirmed_sub_channel = ConfirmedSubChannel {
            own_per_split_point: state.per_split_point,
            counter_per_split_point: sub_channel_accept.first_per_split_point,
            own_split_adaptor_signature: split_tx_adaptor_signature,
            split_tx,
            counter_glue_signature: sub_channel_accept.ln_glue_signature,
            ln_glue_transaction: ln_glue_tx,
            ln_rollback,
            prev_commitment_secret: SecretKey::from_slice(&revoke_and_ack.per_commitment_secret)
                .expect("a valid secret key"),
            next_per_commitment_point: revoke_and_ack.next_per_commitment_point,
            commitment_transactions,
        };

        offered_sub_channel.counter_base_points = Some(accept_points);

        offered_sub_channel.state = SubChannelState::Confirmed(confirmed_sub_channel);

        self.dlc_channel_manager.get_store().upsert_channel(
            Channel::Signed(signed_channel),
            Some(Contract::Signed(signed_contract)),
        )?;
        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&offered_sub_channel)?;

        self.dlc_channel_manager
            .get_store()
            .persist_chain_monitor(&self.dlc_channel_manager.get_chain_monitor().lock().unwrap())?;

        Ok(msg)
    }

    fn on_subchannel_confirm(
        &self,
        sub_channel_confirm: &SubChannelConfirm,
        counter_party: &PublicKey,
    ) -> Result<SubChannelFinalize, Error> {
        let channel_details = self
            .ln_channel_manager
            .get_channel_details(&sub_channel_confirm.channel_id)
            .ok_or_else(|| {
                Error::InvalidParameters(format!(
                    "Unknown LN channel {:02x?}",
                    sub_channel_confirm.channel_id
                ))
            })?;
        let msg = self.ln_channel_manager.with_useable_channel_lock(
            &sub_channel_confirm.channel_id,
            counter_party,
            Some(sub_channel_confirm.commit_tx_number),
            |channel_lock| {
                let (mut accepted_sub_channel, state) = get_sub_channel_in_state!(
                    self.dlc_channel_manager,
                    sub_channel_confirm.channel_id,
                    Accepted,
                    Some(*counter_party)
                )?;

                let accept_revoke_params =
                    accepted_sub_channel.own_base_points.get_revokable_params(
                        self.dlc_channel_manager.get_secp(),
                        &accepted_sub_channel
                            .counter_base_points
                            .as_ref()
                            .expect("to have counter base points")
                            .revocation_basepoint,
                        &state.accept_per_split_point,
                    );

                let funding_redeemscript = &accepted_sub_channel.original_funding_redeemscript;

                dlc::channel::verify_tx_adaptor_signature(
                    self.dlc_channel_manager.get_secp(),
                    &state.split_tx.transaction,
                    accepted_sub_channel.fund_value_satoshis,
                    funding_redeemscript,
                    &channel_details.counter_funding_pubkey.ok_or_else(|| {
                        Error::InvalidState("Counter funding PK is missing".to_string())
                    })?,
                    &accept_revoke_params.publish_pk.inner,
                    &sub_channel_confirm.split_adaptor_signature,
                )
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

                let dlc_channel_id =
                    accepted_sub_channel
                        .get_dlc_channel_id(0)
                        .ok_or(Error::InvalidState(
                            "Could not get dlc channel id".to_string(),
                        ))?;

                let accepted_channel = get_channel_in_state!(
                    self.dlc_channel_manager,
                    &dlc_channel_id,
                    Accepted,
                    Some(*counter_party)
                )?;

                let accepted_contract = get_contract_in_state!(
                    self.dlc_channel_manager,
                    &accepted_channel.accepted_contract_id,
                    Accepted,
                    Some(*counter_party)
                )?;

                let revoke_and_ack = self.ln_channel_manager.on_commitment_signed_get_raa(
                    channel_lock,
                    &sub_channel_confirm.commit_signature,
                    &sub_channel_confirm.htlc_signatures,
                )?;

                let sign_channel = dlc_messages::channel::SignChannel {
                    channel_id: sub_channel_confirm.channel_id.0,
                    cet_adaptor_signatures: sub_channel_confirm.cet_adaptor_signatures.clone(),
                    buffer_adaptor_signature: sub_channel_confirm.buffer_adaptor_signature,
                    refund_signature: sub_channel_confirm.refund_signature,
                    funding_signatures: FundingSignatures {
                        funding_signatures: vec![],
                    },
                    reference_id: None,
                };

                let offer_revoke_params = accepted_sub_channel
                    .counter_base_points
                    .as_ref()
                    .expect("to have counter base points")
                    .get_revokable_params(
                        self.dlc_channel_manager.get_secp(),
                        &accepted_sub_channel.own_base_points.revocation_basepoint,
                        &state.offer_per_split_point,
                    );

                let sub_channel_info = SubChannelVerifyInfo {
                    funding_info: FundingInfo {
                        funding_tx: state.split_tx.transaction.clone(),
                        funding_script_pubkey: state.split_tx.output_script.clone(),
                        funding_input_value: state.split_tx.transaction.output[1].value,
                    },
                    counter_adaptor_pk: offer_revoke_params.own_pk.inner,
                    sub_channel_id: accepted_sub_channel.channel_id,
                };

                let (signed_channel, signed_contract, _) =
                    channel_updater::verify_signed_channel_internal(
                        self.dlc_channel_manager.get_secp(),
                        &accepted_channel,
                        &accepted_contract,
                        &sign_channel,
                        self.dlc_channel_manager.get_wallet(),
                        Some(sub_channel_info),
                        self.dlc_channel_manager.get_chain_monitor(),
                    )?;

                let split_adaptor_signature = self.get_holder_split_tx_adaptor_signature(
                    sub_channel_confirm.channel_id,
                    accepted_sub_channel.fund_value_satoshis,
                    channel_details.channel_keys_id,
                    &state.split_tx.transaction,
                    funding_redeemscript,
                    &offer_revoke_params.publish_pk.inner,
                )?;

                let signed_sub_channel = SignedSubChannel {
                    own_per_split_point: state.accept_per_split_point,
                    counter_per_split_point: state.offer_per_split_point,
                    own_split_adaptor_signature: split_adaptor_signature,
                    counter_split_adaptor_signature: sub_channel_confirm.split_adaptor_signature,
                    split_tx: state.split_tx.clone(),
                    counter_glue_signature: sub_channel_confirm.ln_glue_signature,
                    ln_glue_transaction: state.ln_glue_transaction,
                    ln_rollback: state.ln_rollback,
                };

                let msg = SubChannelFinalize {
                    channel_id: sub_channel_confirm.channel_id,
                    per_commitment_secret: SecretKey::from_slice(
                        &revoke_and_ack.per_commitment_secret,
                    )
                    .expect("a valid secret key"),
                    next_per_commitment_point: revoke_and_ack.next_per_commitment_point,
                    split_adaptor_signature,
                };

                accepted_sub_channel.state = SubChannelState::Finalized(signed_sub_channel);

                self.dlc_channel_manager.get_store().upsert_channel(
                    Channel::Signed(signed_channel),
                    Some(Contract::Confirmed(signed_contract)),
                )?;
                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&accepted_sub_channel)?;
                self.dlc_channel_manager.get_store().persist_chain_monitor(
                    &self.dlc_channel_manager.get_chain_monitor().lock().unwrap(),
                )?;
                Ok(msg)
            },
        )?;

        Ok(msg)
    }

    fn on_sub_channel_finalize(
        &self,
        sub_channel_finalize: &SubChannelFinalize,
        counter_party: &PublicKey,
    ) -> Result<SubChannelRevoke, Error> {
        let channel_details = self
            .ln_channel_manager
            .get_channel_details(&sub_channel_finalize.channel_id)
            .ok_or_else(|| {
                Error::InvalidParameters(format!(
                    "Unknown LN channel {:02x?}",
                    sub_channel_finalize.channel_id
                ))
            })?;
        let msg = self.ln_channel_manager.with_useable_channel_lock(
            &sub_channel_finalize.channel_id,
            counter_party,
            None,
            |channel_lock| {
                let (mut confirmed_sub_channel, state) = get_sub_channel_in_state!(
                    self.dlc_channel_manager,
                    sub_channel_finalize.channel_id,
                    Confirmed,
                    Some(*counter_party)
                )?;

                let funding_redeemscript = &confirmed_sub_channel.original_funding_redeemscript;

                let offer_revoke_params =
                    confirmed_sub_channel.own_base_points.get_revokable_params(
                        self.dlc_channel_manager.get_secp(),
                        &confirmed_sub_channel
                            .counter_base_points
                            .as_ref()
                            .expect("to have counter base points")
                            .revocation_basepoint,
                        &state.own_per_split_point,
                    );

                dlc::channel::verify_tx_adaptor_signature(
                    self.dlc_channel_manager.get_secp(),
                    &state.split_tx.transaction,
                    confirmed_sub_channel.fund_value_satoshis,
                    funding_redeemscript,
                    &channel_details.counter_funding_pubkey.ok_or_else(|| {
                        Error::InvalidState("Counter funding PK is missing".to_string())
                    })?,
                    &offer_revoke_params.publish_pk.inner,
                    &sub_channel_finalize.split_adaptor_signature,
                )
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

                let dlc_channel_id =
                    confirmed_sub_channel
                        .get_dlc_channel_id(0)
                        .ok_or(Error::InvalidState(
                            "Could not get dlc channel id".to_string(),
                        ))?;
                let channel = get_channel_in_state!(
                    self.dlc_channel_manager,
                    &dlc_channel_id,
                    Signed,
                    Some(*counter_party)
                )?;
                let contract = get_contract_in_state!(
                    self.dlc_channel_manager,
                    &channel
                        .get_contract_id()
                        .ok_or_else(|| Error::InvalidState(
                            "No contract id in on_sub_channel_finalize".to_string()
                        ))?,
                    Signed,
                    Some(*counter_party)
                )?;
                let raa = RevokeAndACK {
                    channel_id: sub_channel_finalize.channel_id,
                    per_commitment_secret: sub_channel_finalize
                        .per_commitment_secret
                        .secret_bytes(),
                    next_per_commitment_point: sub_channel_finalize.next_per_commitment_point,
                };

                self.ln_channel_manager.revoke_and_ack(channel_lock, &raa)?;

                self.dlc_channel_manager.get_store().upsert_channel(
                    Channel::Signed(channel),
                    Some(Contract::Confirmed(contract)),
                )?;

                let signed_sub_channel = SignedSubChannel {
                    own_per_split_point: state.own_per_split_point,
                    counter_per_split_point: state.counter_per_split_point,
                    own_split_adaptor_signature: state.own_split_adaptor_signature,
                    counter_split_adaptor_signature: sub_channel_finalize.split_adaptor_signature,
                    split_tx: state.split_tx,
                    ln_glue_transaction: state.ln_glue_transaction,
                    counter_glue_signature: state.counter_glue_signature,
                    ln_rollback: state.ln_rollback,
                };

                let msg = SubChannelRevoke {
                    channel_id: confirmed_sub_channel.channel_id,
                    per_commitment_secret: state.prev_commitment_secret,
                    next_per_commitment_point: state.next_per_commitment_point,
                };

                confirmed_sub_channel.state = SubChannelState::Signed(signed_sub_channel);

                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&confirmed_sub_channel)?;
                Ok(msg)
            },
        )?;

        Ok(msg)
    }

    fn on_sub_channel_revoke(
        &self,
        sub_channel_revoke: &SubChannelRevoke,
        counter_party: &PublicKey,
    ) -> Result<(), Error> {
        self.ln_channel_manager.with_useable_channel_lock(
            &sub_channel_revoke.channel_id,
            counter_party,
            None,
            |channel_lock| {
                let (mut confirmed_sub_channel, state) = get_sub_channel_in_state!(
                    self.dlc_channel_manager,
                    sub_channel_revoke.channel_id,
                    Finalized,
                    Some(*counter_party)
                )?;

                let raa = RevokeAndACK {
                    channel_id: sub_channel_revoke.channel_id,
                    per_commitment_secret: sub_channel_revoke.per_commitment_secret.secret_bytes(),
                    next_per_commitment_point: sub_channel_revoke.next_per_commitment_point,
                };

                self.ln_channel_manager.revoke_and_ack(channel_lock, &raa)?;

                let signed_sub_channel = SignedSubChannel {
                    own_per_split_point: state.own_per_split_point,
                    counter_per_split_point: state.counter_per_split_point,
                    own_split_adaptor_signature: state.own_split_adaptor_signature,
                    counter_split_adaptor_signature: state.counter_split_adaptor_signature,
                    split_tx: state.split_tx,
                    ln_glue_transaction: state.ln_glue_transaction,
                    counter_glue_signature: state.counter_glue_signature,
                    ln_rollback: state.ln_rollback,
                };

                confirmed_sub_channel.state = SubChannelState::Signed(signed_sub_channel);

                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&confirmed_sub_channel)?;
                Ok(())
            },
        )?;

        Ok(())
    }

    fn on_sub_channel_close_offer(
        &self,
        offer: &SubChannelCloseOffer,
        counter_party: &PublicKey,
    ) -> Result<(), Error> {
        let (mut sub_channel, state) = get_sub_channel_in_state!(
            self.dlc_channel_manager,
            offer.channel_id,
            Signed,
            Some(*counter_party)
        )?;

        let dlc_channel_id = sub_channel
            .get_dlc_channel_id(0)
            .ok_or(Error::InvalidState(
                "Could not get dlc channel id".to_string(),
            ))?;

        let dlc_channel = get_channel_in_state!(
            self.dlc_channel_manager,
            &dlc_channel_id,
            Signed,
            None::<PublicKey>
        )?;

        let offer_balance = match dlc_channel.state {
            crate::channel::signed_channel::SignedChannelState::Established {
                total_collateral,
                ..
            } => {
                if total_collateral < offer.accept_balance {
                    return Err(Error::InvalidParameters(
                        "Accept balance must be smaller than total collateral in DLC channel."
                            .to_string(),
                    ));
                }

                total_collateral - offer.accept_balance
            }
            crate::channel::signed_channel::SignedChannelState::Settled {
                own_payout,
                counter_payout,
                ..
            } => {
                if offer.accept_balance != own_payout {
                    return Err(Error::InvalidParameters(
                        "Accept balance must be equal to own payout when DLC channel is settled."
                            .to_string(),
                    ));
                }

                counter_payout
            }
            _ => {
                return Err(Error::InvalidState(
                    "Can only close subchannel that are established or settled".to_string(),
                ));
            }
        };

        let updated = CloseOfferedSubChannel {
            signed_subchannel: state,
            offer_balance,
            accept_balance: offer.accept_balance,
            is_offer: false,
        };

        sub_channel.state = SubChannelState::CloseOffered(updated);

        self.dlc_channel_manager
            .get_store()
            .upsert_sub_channel(&sub_channel)?;

        Ok(())
    }

    fn on_sub_channel_close_accept(
        &self,
        accept: &SubChannelCloseAccept,
        counter_party: &PublicKey,
    ) -> Result<SubChannelCloseConfirm, Error> {
        let channel_details = self
            .ln_channel_manager
            .get_channel_details(&accept.channel_id)
            .ok_or_else(|| {
                Error::InvalidParameters(format!("Unknown channel {:?}", accept.channel_id))
            })?;
        let close_confirm = self.ln_channel_manager.with_useable_channel_lock(
            &accept.channel_id,
            counter_party,
            Some(accept.commit_tx_number),
            |channel_lock| {
                let (mut sub_channel, state) = get_sub_channel_in_state!(
                    self.dlc_channel_manager,
                    accept.channel_id,
                    CloseOffered,
                    Some(*counter_party)
                )?;

                let (offer_fees, _) = per_party_fee(sub_channel.fee_rate_per_vb)?;
                let ln_own_balance_msats = channel_details.outbound_capacity_msat
                    + channel_details.unspendable_punishment_reserve.unwrap_or(0) * 1000
                    + offer_fees * 1000
                    + state.offer_balance * 1000;

                let fund_value = sub_channel.fund_value_satoshis;

                let (commitment_signed, commit_tx_number) = self
                    .ln_channel_manager
                    .get_updated_funding_outpoint_commitment_signed(
                        channel_lock,
                        &state.signed_subchannel.split_tx.transaction.input[0].previous_output,
                        fund_value,
                        ln_own_balance_msats,
                    )?;

                let raa = self.ln_channel_manager.on_commitment_signed_get_raa(
                    channel_lock,
                    &accept.commit_signature,
                    &accept.htlc_signatures,
                )?;

                let per_split_seed = self
                    .dlc_channel_manager
                    .get_wallet()
                    .get_secret_key_for_pubkey(
                        &sub_channel
                            .per_split_seed
                            .expect("to have a per split seed"),
                    )?;

                let per_split_secret = SecretKey::from_slice(&build_commitment_secret(
                    per_split_seed.as_ref(),
                    sub_channel.update_idx,
                ))
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

                let close_confirm = SubChannelCloseConfirm {
                    channel_id: accept.channel_id,
                    commit_signature: commitment_signed.signature,
                    commit_tx_number,
                    htlc_signatures: commitment_signed.htlc_signatures,
                    split_revocation_secret: per_split_secret,
                    commit_revocation_secret: SecretKey::from_slice(&raa.per_commitment_secret)
                        .expect("a valid secret key"),
                    next_per_commitment_point: raa.next_per_commitment_point,
                };

                let funding_txo = lightning::chain::transaction::OutPoint {
                    txid: state.signed_subchannel.split_tx.transaction.input[0]
                        .previous_output
                        .txid,
                    index: state.signed_subchannel.split_tx.transaction.input[0]
                        .previous_output
                        .vout as u16,
                };
                let commitment_transactions = self
                    .ln_chain_monitor
                    .get_latest_holder_commitment_txn(&funding_txo)?;

                let updated_channel = CloseConfirmedSubChannel {
                    signed_subchannel: state.signed_subchannel,
                    own_balance: state.offer_balance,
                    counter_balance: state.accept_balance,
                    ln_rollback: (&channel_details).into(),
                    check_ln_secret: true,
                    commitment_transactions,
                };

                sub_channel.state = SubChannelState::CloseConfirmed(updated_channel);

                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&sub_channel)?;

                self.dlc_channel_manager.get_store().persist_chain_monitor(
                    &self.dlc_channel_manager.get_chain_monitor().lock().unwrap(),
                )?;
                Ok(close_confirm)
            },
        )?;

        Ok(close_confirm)
    }

    fn on_sub_channel_close_confirm(
        &self,
        confirm: &SubChannelCloseConfirm,
        counter_party: &PublicKey,
    ) -> Result<SubChannelCloseFinalize, Error> {
        let finalize = self.ln_channel_manager.with_useable_channel_lock(
            &confirm.channel_id,
            counter_party,
            Some(confirm.commit_tx_number),
            |channel_lock| {
                let (mut sub_channel, state) = get_sub_channel_in_state!(
                    self.dlc_channel_manager,
                    confirm.channel_id,
                    CloseAccepted,
                    Some(*counter_party)
                )?;

                let dlc_channel_id =
                    sub_channel
                        .get_dlc_channel_id(0)
                        .ok_or(Error::InvalidState(
                            "Could not get dlc channel id.".to_string(),
                        ))?;

                let (dlc_channel, contract) = self
                    .dlc_channel_manager
                    .get_closed_sub_dlc_channel(dlc_channel_id, state.own_balance)?;

                if PublicKey::from_secret_key(
                    self.dlc_channel_manager.get_secp(),
                    &confirm.split_revocation_secret,
                ) != state.signed_subchannel.counter_per_split_point
                {
                    return Err(Error::InvalidParameters(
                        "Invalid per update secret in subchannel close confirm".to_string(),
                    )
                    .into());
                }

                sub_channel
                    .counter_party_secrets
                    .provide_secret(
                        sub_channel.update_idx,
                        *confirm.split_revocation_secret.as_ref(),
                    )
                    .map_err(|_| {
                        Error::InvalidParameters("Invalid split revocation secret".to_string())
                    })?;

                let raa = RevokeAndACK {
                    channel_id: confirm.channel_id,
                    per_commitment_secret: *confirm.commit_revocation_secret.as_ref(),
                    next_per_commitment_point: confirm.next_per_commitment_point,
                };

                self.ln_channel_manager.revoke_and_ack(channel_lock, &raa)?;

                let own_raa = self.ln_channel_manager.on_commitment_signed_get_raa(
                    channel_lock,
                    &confirm.commit_signature,
                    &confirm.htlc_signatures,
                )?;

                let per_split_seed = self
                    .dlc_channel_manager
                    .get_wallet()
                    .get_secret_key_for_pubkey(
                        &sub_channel
                            .per_split_seed
                            .expect("to have a per split seed"),
                    )?;

                let per_split_secret = SecretKey::from_slice(&build_commitment_secret(
                    per_split_seed.as_ref(),
                    sub_channel.update_idx,
                ))
                .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

                let finalize = SubChannelCloseFinalize {
                    channel_id: confirm.channel_id,
                    split_revocation_secret: per_split_secret,
                    commit_revocation_secret: Some(
                        SecretKey::from_slice(&own_raa.per_commitment_secret)
                            .expect("a valid secret key"),
                    ),
                    next_per_commitment_point: Some(own_raa.next_per_commitment_point),
                };

                self.dlc_channel_manager
                    .get_chain_monitor()
                    .lock()
                    .unwrap()
                    .add_tx(
                        state.signed_subchannel.split_tx.transaction.txid(),
                        ChannelInfo {
                            channel_id: sub_channel.channel_id.0,
                            tx_type: TxType::Revoked {
                                update_idx: sub_channel.update_idx,
                                own_adaptor_signature: state
                                    .signed_subchannel
                                    .own_split_adaptor_signature,
                                is_offer: sub_channel.is_offer,
                                revoked_tx_type: RevokedTxType::Split,
                            },
                        },
                    );

                sub_channel.state = SubChannelState::OffChainClosed;

                let mut chain_monitor =
                    self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
                chain_monitor.cleanup_channel(dlc_channel_id);

                self.dlc_channel_manager
                    .get_store()
                    .upsert_channel(dlc_channel, contract)?;

                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&sub_channel)?;

                self.dlc_channel_manager
                    .get_store()
                    .persist_chain_monitor(&chain_monitor)?;
                Ok(finalize)
            },
        )?;

        Ok(finalize)
    }

    fn on_sub_channel_close_finalize(
        &self,
        finalize: &SubChannelCloseFinalize,
        counter_party: &PublicKey,
    ) -> Result<(), Error> {
        self.ln_channel_manager.with_useable_channel_lock(
            &finalize.channel_id,
            counter_party,
            None,
            |channel_lock| {
                let (mut sub_channel, state) = get_sub_channel_in_state!(
                    self.dlc_channel_manager,
                    finalize.channel_id,
                    CloseConfirmed,
                    Some(*counter_party)
                )?;

                if PublicKey::from_secret_key(
                    self.dlc_channel_manager.get_secp(),
                    &finalize.split_revocation_secret,
                ) != state.signed_subchannel.counter_per_split_point
                {
                    return Err(Error::InvalidParameters(
                        "Invalid per update secret in subchannel close finalize".to_string(),
                    )
                    .into());
                }

                sub_channel
                    .counter_party_secrets
                    .provide_secret(
                        sub_channel.update_idx,
                        *finalize.split_revocation_secret.as_ref(),
                    )
                    .map_err(|_| {
                        Error::InvalidParameters("Invalid split revocation secret".to_string())
                    })?;

                let dlc_channel_id =
                    sub_channel
                        .get_dlc_channel_id(0)
                        .ok_or(Error::InvalidState(
                            "Could not get dlc channel id.".to_string(),
                        ))?;

                let (dlc_channel, contract) = self
                    .dlc_channel_manager
                    .get_closed_sub_dlc_channel(dlc_channel_id, state.own_balance)?;

                self.dlc_channel_manager
                    .get_chain_monitor()
                    .lock()
                    .unwrap()
                    .add_tx(
                        state.signed_subchannel.split_tx.transaction.txid(),
                        ChannelInfo {
                            channel_id: sub_channel.channel_id.0,
                            tx_type: TxType::Revoked {
                                update_idx: sub_channel.update_idx,
                                own_adaptor_signature: state
                                    .signed_subchannel
                                    .own_split_adaptor_signature,
                                is_offer: sub_channel.is_offer,
                                revoked_tx_type: RevokedTxType::Split,
                            },
                        },
                    );

                if state.check_ln_secret {
                    match (
                        finalize.commit_revocation_secret.as_ref(),
                        finalize.next_per_commitment_point.as_ref(),
                    ) {
                        (Some(secret), Some(point)) => {
                            let revoke_and_ack = RevokeAndACK {
                                channel_id: finalize.channel_id,
                                per_commitment_secret: *secret.as_ref(),
                                next_per_commitment_point: *point,
                            };

                            self.ln_channel_manager
                                .revoke_and_ack(channel_lock, &revoke_and_ack)?;
                        }
                        _ => return Err(APIError::ExternalError {
                            err: "Did not get expected revocation secret and next commitment point"
                                .to_string(),
                        }),
                    };
                }

                sub_channel.state = SubChannelState::OffChainClosed;

                let mut chain_monitor =
                    self.dlc_channel_manager.get_chain_monitor().lock().unwrap();
                chain_monitor.cleanup_channel(dlc_channel_id);

                self.dlc_channel_manager
                    .get_store()
                    .upsert_channel(dlc_channel, contract)?;

                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&sub_channel)?;

                self.dlc_channel_manager
                    .get_store()
                    .persist_chain_monitor(&chain_monitor)?;
                Ok(())
            },
        )?;

        Ok(())
    }

    /// Process pending actions, potentially generating messages that should be sent to the
    /// adequate peer.
    fn process_actions(&self) -> Vec<(SubChannelMessage, PublicKey)> {
        let mut actions = self.actions.lock().unwrap();
        let mut retain = Vec::new();
        let mut msgs = Vec::new();

        for action in actions.drain(..) {
            match action {
                Action::ResendOffer((o, p)) => msgs.push((SubChannelMessage::Offer(o), p)),
                Action::ReAccept {
                    channel_id,
                    party_params,
                    funding_inputs_info,
                    accept_points,
                    per_update_seed_pk,
                } => {
                    if let Some(details) = self.ln_channel_manager.get_channel_details(&channel_id)
                    {
                        if details.is_usable {
                            if let Ok((p, msg)) = self.accept_sub_channel_internal(
                                &channel_id,
                                Some((
                                    party_params.clone(),
                                    funding_inputs_info.clone(),
                                    accept_points.clone(),
                                    per_update_seed_pk,
                                )),
                            ) {
                                msgs.push((SubChannelMessage::Accept(msg), p));
                            } else {
                                error!(
                                    "Could not re-accept sub channel {:?}, keeping the action",
                                    channel_id
                                );
                                retain.push(Action::ReAccept {
                                    channel_id,
                                    party_params,
                                    funding_inputs_info,
                                    accept_points,
                                    per_update_seed_pk,
                                });
                            }
                        } else {
                            trace!(
                                "Channel {:?} not yet useable, keeping the re-accept action",
                                channel_id
                            );
                            retain.push(Action::ReAccept {
                                channel_id,
                                party_params,
                                funding_inputs_info,
                                accept_points,
                                per_update_seed_pk,
                            });
                        }
                    } else {
                        error!(
                            "Could not get channel details for id: {:?}, giving up re-accepting",
                            channel_id
                        );
                    };
                }
                Action::ForceSign(id) => {
                    if let Some(details) = self.ln_channel_manager.get_channel_details(&id) {
                        if details.is_usable {
                            if let Err(e) = self.mark_channel_signed(id) {
                                error!("Unexpected error {} marking channel {:?} as signed, keeping the action to retry.", e, id);
                                retain.push(Action::ForceSign(id));
                            }
                        } else {
                            info!("Could not mark channel {:?} as signed as it was not usable, keeping the action to retry.", id);
                            retain.push(Action::ForceSign(id));
                        }
                    } else {
                        error!("Could not get channel details for id: {:?}", id);
                    };
                }
                Action::ResendCloseOffer((offer, pk)) => {
                    msgs.push((SubChannelMessage::CloseOffer(offer), pk));
                }
                Action::ReAcceptCloseOffer {
                    channel_id,
                    own_balance,
                } => {
                    if let Some(details) = self.ln_channel_manager.get_channel_details(&channel_id)
                    {
                        if details.is_usable {
                            if let Ok((msg, p)) = self.accept_subchannel_close_offer(&channel_id) {
                                msgs.push((SubChannelMessage::CloseAccept(msg), p));
                            } else {
                                error!(
                                    "Could not re-accept close for sub channel {:?}, keeping the action",
                                    channel_id
                                );
                                retain.push(Action::ReAcceptCloseOffer {
                                    channel_id,
                                    own_balance,
                                });
                            }
                        } else {
                            trace!(
                                "Channel {:?} not yet useable, keeping the re-accept close action",
                                channel_id
                            );
                            retain.push(Action::ReAcceptCloseOffer {
                                channel_id,
                                own_balance,
                            });
                        }
                    } else {
                        error!(
                            "Could not get channel details for id: {:?}, giving up re-accepting the close offer",
                            channel_id
                        );
                    };
                }
                Action::ResendCloseFinalize((msg, pk)) => {
                    msgs.push((SubChannelMessage::CloseFinalize(msg), pk));
                }
            };
        }

        actions.append(&mut retain);

        msgs
    }

    /// Checks for watched transactions, process pending actions and tries to finalize the closing
    /// of sub channel whose closing has been initiated by the local or remote party. The returned
    /// messages should be sent to the peer with the associated public key.
    pub fn periodic_check(&self) -> Vec<(SubChannelMessage, PublicKey)> {
        if let Err(e) = self.check_for_watched_tx() {
            error!("Error checking for watched transactions: {}", e);
        }

        let msgs = self.process_actions();

        if let Ok(sub_channels) = self.dlc_channel_manager.get_store().get_sub_channels() {
            let closing_sub_channels = sub_channels.iter().filter(|x| {
                if let SubChannelState::Closing(_) = &x.state {
                    true
                } else {
                    false
                }
            });

            for c in closing_sub_channels {
                if let Err(e) = self.finalize_force_close_sub_channels(&c.channel_id) {
                    warn!(
                        "Could not finalize force closing of sub channel {:?}: {}",
                        c.channel_id, e
                    );
                }
            }
        }

        msgs
    }

    /// Check if any of the watched transactions have been confirmed on chain.
    ///
    /// All confirmed transactions are then processed depending on their [`TxType`].
    fn check_for_watched_tx(&self) -> Result<(), Error> {
        let mut chain_monitor = self.dlc_channel_manager.get_chain_monitor().lock().unwrap();

        //Todo(tibo): all db commit should happen at once otherwise state might get corrupted.

        let confirmed_txs = chain_monitor.confirmed_txs();

        for (tx, channel_info) in &confirmed_txs {
            log::info!(
                "Transaction {} confirmed for channel {}. Type: {:?}",
                tx.txid(),
                channel_info.channel_id.to_hex(),
                channel_info.tx_type,
            );

            let mut sub_channel = match self
                .dlc_channel_manager
                .get_store()
                .get_sub_channel(ChannelId::from_bytes(channel_info.channel_id))?
            {
                None => {
                    log::error!(
                        "Cannot process confirmed transaction {} for unknown subchannel {}",
                        tx.txid(),
                        channel_info.channel_id.to_hex()
                    );
                    continue;
                }
                Some(s) => s,
            };

            if let TxType::SplitTx = channel_info.tx_type {
                // TODO(tibo): should only considered closed after some confirmations.
                // Ideally should save previous state, and maybe restore in
                // case of reorg, though if the counter party has sent the
                // tx to close the channel it is unlikely that the tx will
                // not be part of a future block.
                let (state, commitment_transactions) = match &sub_channel.state {
                    SubChannelState::Signed(s) => (s, None),
                    SubChannelState::Closing(_) => {
                        log::info!("Spotted closing split transaction on chain");
                        continue;
                    }
                    SubChannelState::CloseOffered(s) => (&s.signed_subchannel, None),
                    SubChannelState::CloseAccepted(s) => {
                        if let Err(e) = self.ln_channel_manager.with_channel_lock_no_check(
                            &sub_channel.channel_id,
                            &sub_channel.counter_party,
                            |channel_lock| {
                                self.ln_channel_manager.set_funding_outpoint(
                                    channel_lock,
                                    &lightning::chain::transaction::OutPoint {
                                        txid: s.signed_subchannel.split_tx.transaction.txid(),
                                        index: 0,
                                    },
                                    s.ln_rollback.channel_value_satoshis,
                                    s.ln_rollback.value_to_self_msat,
                                );
                                Ok(())
                            },
                        ) {
                            log::error!("Could not reset funding outpoint: {:?}", e);
                        }
                        (
                            &s.signed_subchannel,
                            Some(s.commitment_transactions.clone()),
                        )
                    }
                    SubChannelState::CloseConfirmed(s) => {
                        if let Err(e) = self.ln_channel_manager.with_channel_lock_no_check(
                            &sub_channel.channel_id,
                            &sub_channel.counter_party,
                            |channel_lock| {
                                self.ln_channel_manager.set_funding_outpoint(
                                    channel_lock,
                                    &lightning::chain::transaction::OutPoint {
                                        txid: s.signed_subchannel.split_tx.transaction.txid(),
                                        index: 0,
                                    },
                                    s.ln_rollback.channel_value_satoshis,
                                    s.ln_rollback.value_to_self_msat,
                                );
                                Ok(())
                            },
                        ) {
                            log::error!("Could not reset funding outpoint: {:?}", e);
                        }
                        (
                            &s.signed_subchannel,
                            Some(s.commitment_transactions.clone()),
                        )
                    }
                    _ => {
                        log::error!("Unexpected channel state");
                        continue;
                    }
                };

                log::info!("Spotted split transaction, marking sub channel as closing");
                let closing_sub_channel = ClosingSubChannel {
                    signed_sub_channel: state.clone(),
                    is_initiator: false,
                    commitment_transactions,
                };
                chain_monitor.remove_tx(&tx.txid());
                sub_channel.state = SubChannelState::Closing(closing_sub_channel);
                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&sub_channel)?;
                continue;
            } else if let TxType::Revoked {
                update_idx,
                own_adaptor_signature,
                is_offer,
                revoked_tx_type,
            } = channel_info.tx_type
            {
                if let RevokedTxType::Split = revoked_tx_type {
                    let secret = sub_channel
                        .counter_party_secrets
                        .get_secret(update_idx)
                        .expect("to be able to retrieve the per update secret");
                    let counter_per_update_secret = SecretKey::from_slice(&secret)
                        .expect("to be able to parse the counter per update secret.");

                    let per_update_seed_pk = sub_channel
                        .per_split_seed
                        .expect("to have a per split seed");

                    let per_update_seed_sk = self
                        .dlc_channel_manager
                        .get_wallet()
                        .get_secret_key_for_pubkey(&per_update_seed_pk)?;

                    let per_update_secret = SecretKey::from_slice(&build_commitment_secret(
                        per_update_seed_sk.as_ref(),
                        update_idx,
                    ))
                    .expect("a valid secret key.");

                    let per_update_point = PublicKey::from_secret_key(
                        self.dlc_channel_manager.get_secp(),
                        &per_update_secret,
                    );

                    let own_revocation_params = sub_channel.own_base_points.get_revokable_params(
                        self.dlc_channel_manager.get_secp(),
                        &sub_channel
                            .counter_base_points
                            .as_ref()
                            .expect("to have counter base points")
                            .revocation_basepoint,
                        &per_update_point,
                    );

                    let counter_per_update_point = PublicKey::from_secret_key(
                        self.dlc_channel_manager.get_secp(),
                        &counter_per_update_secret,
                    );

                    let base_own_sk = self
                        .dlc_channel_manager
                        .get_wallet()
                        .get_secret_key_for_pubkey(&sub_channel.own_base_points.own_basepoint)?;

                    let own_sk = derive_private_key(
                        self.dlc_channel_manager.get_secp(),
                        &per_update_point,
                        &base_own_sk,
                    );

                    let counter_revocation_params = sub_channel
                        .counter_base_points
                        .as_ref()
                        .expect("to have counter base points")
                        .get_revokable_params(
                            self.dlc_channel_manager.get_secp(),
                            &sub_channel.own_base_points.revocation_basepoint,
                            &counter_per_update_point,
                        );

                    let witness = if sub_channel.own_fund_pk < sub_channel.counter_fund_pk {
                        tx.input[0].witness.to_vec().remove(1)
                    } else {
                        tx.input[0].witness.to_vec().remove(2)
                    };

                    let sig_data = witness
                        .iter()
                        .take(witness.len() - 1)
                        .cloned()
                        .collect::<Vec<_>>();
                    let own_sig = Signature::from_der(&sig_data)?;

                    let counter_sk = own_adaptor_signature.recover(
                        self.dlc_channel_manager.get_secp(),
                        &own_sig,
                        &counter_revocation_params.publish_pk.inner,
                    )?;

                    let own_revocation_base_secret = &self
                        .dlc_channel_manager
                        .get_wallet()
                        .get_secret_key_for_pubkey(
                            &sub_channel.own_base_points.revocation_basepoint,
                        )?;

                    let counter_revocation_sk = derive_private_revocation_key(
                        self.dlc_channel_manager.get_secp(),
                        &counter_per_update_secret,
                        own_revocation_base_secret,
                    );

                    let (offer_params, accept_params) = if is_offer {
                        (&own_revocation_params, &counter_revocation_params)
                    } else {
                        (&counter_revocation_params, &own_revocation_params)
                    };

                    let fee_rate_per_vb: u64 = (self
                        .dlc_channel_manager
                        .get_fee_estimator()
                        .get_est_sat_per_1000_weight(
                            lightning::chain::chaininterface::ConfirmationTarget::HighPriority,
                        )
                        / 250)
                        .into();

                    let signed_tx =
                        dlc::channel::sub_channel::create_and_sign_punish_split_transaction(
                            self.dlc_channel_manager.get_secp(),
                            offer_params,
                            accept_params,
                            &own_sk,
                            &counter_sk,
                            &counter_revocation_sk,
                            tx,
                            &self.dlc_channel_manager.get_wallet().get_new_address()?,
                            0,
                            fee_rate_per_vb,
                        )?;

                    self.dlc_channel_manager
                        .get_blockchain()
                        .send_transaction(&signed_tx)?;

                    sub_channel.state = SubChannelState::ClosedPunished(signed_tx.txid());

                    self.dlc_channel_manager
                        .get_store()
                        .upsert_sub_channel(&sub_channel)?;
                }
            } else if let TxType::CollaborativeClose = channel_info.tx_type {
                todo!();
                // signed_channel.state = SignedChannelState::CollaborativelyClosed;
                // self.dlc_channel_manager.get_store()
                //     .upsert_channel(Channel::Signed(signed_channel), None)?;
            }
        }

        self.dlc_channel_manager
            .get_store()
            .persist_chain_monitor(&chain_monitor)?;

        Ok(())
    }

    /// Called when a reestablish message is received by the local node.
    fn on_channel_reestablish(
        &self,
        peer_id: &PublicKey,
        channel_id: ChannelId,
        peer_state: Option<u8>,
    ) -> Result<(), Error> {
        if let Some(mut channel) = self
            .dlc_channel_manager
            .get_store()
            .get_sub_channel(channel_id)?
        {
            if &channel.counter_party != peer_id {
                return Err(Error::InvalidParameters(format!(
                    "Channel {:?} is not established with peer {}",
                    channel_id, peer_id
                )));
            }
            let mut updated_state = None;
            match &channel.state {
                SubChannelState::Offered(o) if channel.is_offer => {
                    let has_not_received = match peer_state {
                        None => true,
                        Some(state) if state == ReestablishFlag::OffChainClosed as u8 => true,
                        Some(state) if state == ReestablishFlag::CloseConfirmed as u8 => {
                            let finalize = self.get_reconnect_close_finalize(&channel, true)?;

                            self.actions
                                .lock()
                                .unwrap()
                                .push(Action::ResendCloseFinalize((
                                    finalize,
                                    channel.counter_party,
                                )));
                            true
                        }
                        _ => false,
                    };
                    if has_not_received {
                        let dlc_channel_id = channel.get_dlc_channel_id(0).ok_or_else(|| {
                            Error::InvalidState("Could not get dlc channel id".to_string())
                        })?;
                        let dlc_channel = get_channel_in_state!(
                            self.dlc_channel_manager,
                            &dlc_channel_id,
                            Offered,
                            None::<PublicKey>
                        )?;
                        let contract = get_contract_in_state!(
                            self.dlc_channel_manager,
                            &dlc_channel.offered_contract_id,
                            Offered,
                            None::<PublicKey>
                        )?;
                        let offer_msg = SubChannelOffer {
                            channel_id,
                            revocation_basepoint: channel.own_base_points.revocation_basepoint,
                            publish_basepoint: channel.own_base_points.publish_basepoint,
                            own_basepoint: channel.own_base_points.own_basepoint,
                            next_per_split_point: o.per_split_point,
                            contract_info: (&contract).into(),
                            channel_revocation_basepoint: dlc_channel
                                .party_points
                                .revocation_basepoint,
                            channel_publish_basepoint: dlc_channel.party_points.publish_basepoint,
                            channel_own_basepoint: dlc_channel.party_points.own_basepoint,
                            channel_first_per_update_point: dlc_channel.per_update_point,
                            payout_spk: contract.offer_params.payout_script_pubkey.clone(),
                            payout_serial_id: contract.offer_params.payout_serial_id,
                            offer_collateral: contract.offer_params.collateral,
                            cet_locktime: contract.cet_locktime,
                            refund_locktime: contract.refund_locktime,
                            cet_nsequence: crate::manager::CET_NSEQUENCE,
                            fee_rate_per_vbyte: contract.fee_rate_per_vb,
                        };
                        self.actions
                            .lock()
                            .unwrap()
                            .push(Action::ResendOffer((offer_msg, contract.counter_party)));
                    }
                }
                SubChannelState::Accepted(a) => {
                    self.ln_channel_manager
                        .with_useable_channel_lock(
                            &channel.channel_id,
                            peer_id,
                            None,
                            |channel_lock| {
                                let dlc_channel_id =
                                    channel.get_dlc_channel_id(0).ok_or_else(|| {
                                        Error::InvalidState(
                                            "Could not get dlc channel id".to_string(),
                                        )
                                    })?;
                                let dlc_channel = get_channel_in_state!(
                                    self.dlc_channel_manager,
                                    &dlc_channel_id,
                                    Accepted,
                                    None::<PublicKey>
                                )?;
                                let contract = get_contract_in_state!(
                                    self.dlc_channel_manager,
                                    &dlc_channel.accepted_contract_id,
                                    Accepted,
                                    None::<PublicKey>
                                )?;
                                let offered_channel = OfferedChannel {
                                    offered_contract_id: contract.offered_contract.id,
                                    temporary_channel_id: dlc_channel.temporary_channel_id,
                                    party_points: dlc_channel.offer_base_points,
                                    per_update_point: dlc_channel.offer_per_update_point,
                                    offer_per_update_seed: None,
                                    is_offer_party: false,
                                    counter_party: dlc_channel.counter_party,
                                    cet_nsequence: CET_NSEQUENCE,
                                    reference_id: None,
                                };
                                self.dlc_channel_manager
                                    .get_store()
                                    .upsert_sub_channel(&channel)?;
                                self.dlc_channel_manager.get_store().upsert_channel(
                                    Channel::Offered(offered_channel),
                                    Some(Contract::Offered(contract.offered_contract)),
                                )?;
                                let party_params = contract.accept_params.clone();
                                let funding_inputs_info = contract.funding_inputs;
                                let accept_points = dlc_channel.accept_base_points.clone();
                                let per_update_seed_pk = dlc_channel.accept_per_update_seed;
                                self.actions.lock().unwrap().push(Action::ReAccept {
                                    channel_id,
                                    party_params,
                                    funding_inputs_info,
                                    accept_points,
                                    per_update_seed_pk,
                                });

                                self.ln_channel_manager.set_funding_outpoint(
                                    channel_lock,
                                    &a.ln_rollback.funding_outpoint,
                                    a.ln_rollback.channel_value_satoshis,
                                    a.ln_rollback.value_to_self_msat,
                                );
                                updated_state = Some(SubChannelState::Offered(OfferedSubChannel {
                                    per_split_point: a.offer_per_split_point,
                                }));

                                Ok(())
                            },
                        )
                        .map_err(|e| Error::InvalidState(format!("{:?}", e)))?;
                }
                SubChannelState::Confirmed(a) => {
                    self.ln_channel_manager
                        .with_useable_channel_lock(
                            &channel.channel_id,
                            peer_id,
                            None,
                            |channel_lock| {
                                let dlc_channel_id =
                                    channel.get_dlc_channel_id(0).ok_or_else(|| {
                                        Error::InvalidState(
                                            "Could not get dlc channel id".to_string(),
                                        )
                                    })?;
                                let dlc_channel = get_channel_in_state!(
                                    self.dlc_channel_manager,
                                    &dlc_channel_id,
                                    Signed,
                                    None::<PublicKey>
                                )?;
                                let contract = get_contract_in_state!(
                                    self.dlc_channel_manager,
                                    &dlc_channel
                                        .get_contract_id()
                                        .expect("Signed contract should have a contract id"),
                                    Signed,
                                    None::<PublicKey>
                                )?;
                                let offered_channel = OfferedChannel {
                                    offered_contract_id: contract
                                        .accepted_contract
                                        .offered_contract
                                        .id,
                                    temporary_channel_id: dlc_channel.temporary_channel_id,
                                    party_points: dlc_channel.own_points,
                                    per_update_point: dlc_channel.own_per_update_point,
                                    offer_per_update_seed: Some(dlc_channel.own_per_update_seed),
                                    is_offer_party: true,
                                    counter_party: dlc_channel.counter_party,
                                    // TODO(tibo): use value from original offer
                                    cet_nsequence: CET_NSEQUENCE,
                                    reference_id: None,
                                };
                                self.ln_channel_manager.set_funding_outpoint(
                                    channel_lock,
                                    &a.ln_rollback.funding_outpoint,
                                    a.ln_rollback.channel_value_satoshis,
                                    a.ln_rollback.value_to_self_msat,
                                );
                                self.dlc_channel_manager.get_store().upsert_channel(
                                    Channel::Offered(offered_channel),
                                    Some(Contract::Offered(
                                        contract.accepted_contract.offered_contract,
                                    )),
                                )?;
                                updated_state = Some(SubChannelState::Offered(OfferedSubChannel {
                                    per_split_point: a.own_per_split_point,
                                }));
                                Ok(())
                            },
                        )
                        .map_err(|e| Error::InvalidState(format!("{:?}", e)))?;
                }
                SubChannelState::Finalized(signed) => {
                    if let Some(counter_state) = peer_state {
                        if counter_state == ReestablishFlag::Signed as u8 {
                            self.actions
                                .lock()
                                .unwrap()
                                .push(Action::ForceSign(channel_id));
                        } else {
                            self.ln_channel_manager
                                .with_useable_channel_lock(
                                    &channel.channel_id,
                                    peer_id,
                                    None,
                                    |channel_lock| {
                                        let dlc_channel_id =
                                            channel.get_dlc_channel_id(0).ok_or_else(|| {
                                                Error::InvalidState(
                                                    "Could not get dlc channel id".to_string(),
                                                )
                                            })?;
                                        let dlc_channel = get_channel_in_state!(
                                            self.dlc_channel_manager,
                                            &dlc_channel_id,
                                            Signed,
                                            None::<PublicKey>
                                        )?;
                                        let contract = get_contract_in_state!(
                                            self.dlc_channel_manager,
                                            &dlc_channel.get_contract_id().expect(
                                                "Signed contract should have a contract id"
                                            ),
                                            Confirmed,
                                            None::<PublicKey>
                                        )?;
                                        let offered_channel = OfferedChannel {
                                            offered_contract_id: contract
                                                .accepted_contract
                                                .offered_contract
                                                .id,
                                            temporary_channel_id: dlc_channel.temporary_channel_id,
                                            party_points: dlc_channel.counter_points,
                                            per_update_point: dlc_channel.counter_per_update_point,
                                            offer_per_update_seed: None,
                                            is_offer_party: false,
                                            counter_party: dlc_channel.counter_party,
                                            cet_nsequence: CET_NSEQUENCE,
                                            reference_id: None,
                                        };
                                        self.dlc_channel_manager
                                            .get_store()
                                            .upsert_sub_channel(&channel)?;
                                        self.dlc_channel_manager.get_store().upsert_channel(
                                            Channel::Offered(offered_channel),
                                            Some(Contract::Offered(
                                                contract.accepted_contract.offered_contract,
                                            )),
                                        )?;
                                        let party_params =
                                            contract.accepted_contract.accept_params.clone();
                                        let funding_inputs_info =
                                            contract.accepted_contract.funding_inputs;
                                        let accept_points = dlc_channel.own_points.clone();
                                        let per_update_seed_pk = dlc_channel.own_per_update_seed;
                                        self.actions.lock().unwrap().push(Action::ReAccept {
                                            channel_id,
                                            party_params,
                                            funding_inputs_info,
                                            accept_points,
                                            per_update_seed_pk,
                                        });

                                        self.ln_channel_manager.set_funding_outpoint(
                                            channel_lock,
                                            &signed.ln_rollback.funding_outpoint,
                                            signed.ln_rollback.channel_value_satoshis,
                                            signed.ln_rollback.value_to_self_msat,
                                        );
                                        updated_state =
                                            Some(SubChannelState::Offered(OfferedSubChannel {
                                                per_split_point: signed.counter_per_split_point,
                                            }));
                                        Ok(())
                                    },
                                )
                                .map_err(|e| Error::InvalidState(format!("{:?}", e)))?;
                        }
                    }
                }
                SubChannelState::CloseOffered(offered) if offered.is_offer => {
                    if let Some(counter_state) = peer_state {
                        if counter_state == ReestablishFlag::Signed as u8 {
                            let message = SubChannelCloseOffer {
                                channel_id,
                                accept_balance: offered.accept_balance,
                            };

                            self.actions
                                .lock()
                                .unwrap()
                                .push(Action::ResendCloseOffer((message, channel.counter_party)));
                        }
                    }
                }
                SubChannelState::CloseAccepted(accepted) => {
                    self.ln_channel_manager.with_useable_channel_lock(
                        &channel.channel_id,
                        &channel.counter_party,
                        None,
                        |channel_lock| {
                            self.ln_channel_manager.set_funding_outpoint(
                                channel_lock,
                                &accepted.ln_rollback.funding_outpoint,
                                accepted.ln_rollback.channel_value_satoshis,
                                accepted.ln_rollback.value_to_self_msat,
                            );
                            self.actions
                                .lock()
                                .unwrap()
                                .push(Action::ReAcceptCloseOffer {
                                    channel_id,
                                    own_balance: accepted.own_balance,
                                });

                            let close_offered = CloseOfferedSubChannel {
                                signed_subchannel: accepted.signed_subchannel.clone(),
                                offer_balance: accepted.counter_balance,
                                accept_balance: accepted.own_balance,
                                is_offer: false,
                            };

                            updated_state = Some(SubChannelState::CloseOffered(close_offered));
                            Ok(())
                        },
                    )?;
                }
                SubChannelState::CloseConfirmed(confirmed) => {
                    if let Some(counter_state) = peer_state {
                        if counter_state == ReestablishFlag::CloseAccepted as u8 {
                            self.ln_channel_manager.with_useable_channel_lock(
                                &channel.channel_id,
                                &channel.counter_party,
                                None,
                                |channel_lock| {
                                    self.ln_channel_manager.set_funding_outpoint(
                                        channel_lock,
                                        &confirmed.ln_rollback.funding_outpoint,
                                        confirmed.ln_rollback.channel_value_satoshis,
                                        confirmed.ln_rollback.value_to_self_msat,
                                    );
                                    updated_state = Some(SubChannelState::CloseOffered(
                                        CloseOfferedSubChannel {
                                            signed_subchannel: confirmed.signed_subchannel.clone(),
                                            offer_balance: confirmed.own_balance,
                                            accept_balance: confirmed.counter_balance,
                                            is_offer: true,
                                        },
                                    ));
                                    Ok(())
                                },
                            )?;
                        } else {
                            // LDK will provide the revocation secret through reestablishment.
                            let mut confirmed = confirmed.clone();
                            confirmed.check_ln_secret = false;
                            updated_state = Some(SubChannelState::CloseConfirmed(confirmed));
                        }
                    }
                }
                SubChannelState::OffChainClosed => {
                    if let Some(counter_state) = peer_state {
                        let finalize = self.get_reconnect_close_finalize(&channel, false)?;
                        if counter_state == ReestablishFlag::CloseConfirmed as u8 {
                            self.actions
                                .lock()
                                .unwrap()
                                .push(Action::ResendCloseFinalize((
                                    finalize,
                                    channel.counter_party,
                                )));
                        }
                    }
                }
                _ => {}
            };

            if let Some(state) = updated_state {
                channel.state = state;
                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&channel)?;
            }
        }

        if let Err(e) = self
            .dlc_channel_manager
            .get_store()
            .save_sub_channel_actions(&self.actions.lock().unwrap())
        {
            error!("Could not save sub channel manager actions: {}", e);
        }

        Ok(())
    }

    fn get_reconnect_close_finalize(
        &self,
        channel: &SubChannel,
        // when the channel has been offered again already, the offer party will have decreased its
        // update index, so we need to restore it to provide a proper split secret.
        restore_index: bool,
    ) -> Result<SubChannelCloseFinalize, Error> {
        let per_split_seed = self
            .dlc_channel_manager
            .get_wallet()
            .get_secret_key_for_pubkey(
                &channel.per_split_seed.expect("to have a per split seed"),
            )?;

        let update_index = if restore_index {
            channel.update_idx + 1
        } else {
            channel.update_idx
        };
        let per_split_secret = SecretKey::from_slice(&build_commitment_secret(
            per_split_seed.as_ref(),
            update_index,
        ))
        .map_err(|e| APIError::ExternalError { err: e.to_string() })?;

        Ok(SubChannelCloseFinalize {
            channel_id: channel.channel_id,
            split_revocation_secret: per_split_secret,
            commit_revocation_secret: None,
            next_per_commitment_point: None,
        })
    }

    fn on_sub_channel_reject(&self, reject: &Reject, peer_id: &PublicKey) -> Result<(), Error> {
        let sub_channel = self
            .dlc_channel_manager
            .get_store()
            .get_sub_channel(reject.channel_id)?;

        match sub_channel {
            None => {
                return Err(Error::InvalidParameters(format!(
                    "No such subchannel: {:?}",
                    reject.channel_id
                )))
            }
            Some(mut s) => {
                if s.counter_party != *peer_id {
                    return Err(Error::InvalidParameters(
                        "Message from invalid peer".to_string(),
                    ));
                }
                match s.state {
                    SubChannelState::Offered(_) => {
                        s.state = SubChannelState::Rejected;
                    }
                    SubChannelState::CloseOffered(o) => {
                        s.state = SubChannelState::Signed(o.signed_subchannel);
                    }
                    _ => {
                        return Err(Error::InvalidParameters(
                            "Not in a state to be rejected".to_string(),
                        ))
                    }
                };

                self.dlc_channel_manager
                    .get_store()
                    .upsert_sub_channel(&s)?;
            }
        }

        Ok(())
    }

    fn get_closed_dlc_channel_and_contract(
        &self,
        channel_id: DlcChannelId,
        counter_closed: bool,
    ) -> Result<(Channel, Contract), Error> {
        let channel = self
            .dlc_channel_manager
            .get_store()
            .get_channel(&channel_id)?
            .ok_or(Error::InvalidParameters(format!(
                "No such channel {:?}",
                channel_id
            )))?;

        let closed_channel_data = ClosedChannel {
            counter_party: channel.get_counter_party_id(),
            temporary_channel_id: channel.get_temporary_id(),
            channel_id: channel.get_id(),
            reference_id: None,
            // TODO(holzeis): Ignoring closing txid on dlc channels for sub channels
            closing_txid: Txid::all_zeros(),
        };
        let closed_channel = if counter_closed {
            Channel::CounterClosed(closed_channel_data)
        } else {
            Channel::Closed(closed_channel_data)
        };
        let contract_id = channel
            .get_contract_id()
            .ok_or(Error::InvalidParameters(format!(
                "Channel {:?} does not have a contract associated",
                channel_id
            )))?;
        let contract = self
            .dlc_channel_manager
            .get_store()
            .get_contract(&contract_id)?
            .ok_or(Error::InvalidParameters(format!(
                "No such contract {:?}",
                contract_id
            )))?;
        let closed_contract = Contract::Closed(ClosedContract {
            attestations: None,
            signed_cet: None,
            contract_id,
            temporary_contract_id: contract.get_id(),
            counter_party_id: contract.get_counter_party_id(),
            pnl: 0,
        });
        Ok((closed_channel, closed_contract))
    }

    fn get_holder_split_tx_signature(
        &self,
        sub_channel: &SubChannel,
        split_tx: &Transaction,
    ) -> Result<Signature, Error> {
        let mut signers = self.ln_channel_signers.lock().unwrap();

        let channel_keys_id = match sub_channel.channel_keys_id {
            Some(channel_keys_id) => channel_keys_id,
            None => {
                let channel_id = sub_channel.channel_id;
                let channel_details = self
                    .ln_channel_manager
                    .get_channel_details(&channel_id)
                    .ok_or_else(|| {
                        Error::InvalidParameters(format!("Unknown LN channel {channel_id:02x?}"))
                    })?;
                channel_details.channel_keys_id
            }
        };

        let signer = signers.entry(sub_channel.channel_id).or_insert(
            self.signer_provider
                .derive_ln_dlc_channel_signer(sub_channel.fund_value_satoshis, channel_keys_id),
        );
        signer.get_holder_split_tx_signature(
            self.dlc_channel_manager.get_secp(),
            split_tx,
            &sub_channel.original_funding_redeemscript,
            sub_channel.fund_value_satoshis,
        )
    }

    fn get_holder_split_tx_adaptor_signature(
        &self,
        channel_id: ChannelId,
        channel_value_satoshis: u64,
        channel_keys_id: [u8; 32],
        split_tx: &Transaction,
        funding_redeemscript: &Script,
        counter_publish_pk: &PublicKey,
    ) -> Result<EcdsaAdaptorSignature, Error> {
        let mut signers = self.ln_channel_signers.lock().unwrap();

        let signer = signers.entry(channel_id).or_insert(
            self.signer_provider
                .derive_ln_dlc_channel_signer(channel_value_satoshis, channel_keys_id),
        );

        signer.get_holder_split_tx_adaptor_signature(
            self.dlc_channel_manager.get_secp(),
            split_tx,
            channel_value_satoshis,
            funding_redeemscript,
            counter_publish_pk,
        )
    }
}

impl<
        W: Deref,
        M: Deref,
        C: Deref,
        S: Deref,
        B: Deref,
        O: Deref,
        T: Deref,
        F: Deref,
        K: Deref,
        D: Deref<Target = Manager<W, B, S, O, T, F>>,
        CS: ChannelSigner,
        SP: Deref,
        LCS: LnDlcChannelSigner,
    > ChannelMessageHandler for SubChannelManager<W, M, C, S, B, O, T, F, D, CS, SP, LCS, K>
where
    W::Target: Wallet,
    M::Target: LNChannelManager<K>,
    C::Target: LNChainMonitor,
    S::Target: Storage,
    B::Target: Blockchain,
    O::Target: Oracle,
    T::Target: Time,
    F::Target: FeeEstimator,
    SP::Target: LnDlcSignerProvider<LCS>,
    K::Target: SignerProvider,
{
    fn handle_open_channel(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::OpenChannel,
    ) {
        self.ln_channel_manager
            .handle_open_channel(their_node_id, msg)
    }

    fn handle_accept_channel(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::AcceptChannel,
    ) {
        self.ln_channel_manager
            .handle_accept_channel(their_node_id, msg)
    }

    fn handle_funding_created(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::FundingCreated,
    ) {
        self.ln_channel_manager
            .handle_funding_created(their_node_id, msg)
    }

    fn handle_funding_signed(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::FundingSigned,
    ) {
        self.ln_channel_manager
            .handle_funding_signed(their_node_id, msg)
    }

    fn handle_channel_ready(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::ChannelReady,
    ) {
        self.ln_channel_manager
            .handle_channel_ready(their_node_id, msg)
    }

    fn handle_shutdown(&self, their_node_id: &PublicKey, msg: &lightning::ln::msgs::Shutdown) {
        self.ln_channel_manager.handle_shutdown(their_node_id, msg)
    }

    fn handle_closing_signed(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::ClosingSigned,
    ) {
        self.ln_channel_manager
            .handle_closing_signed(their_node_id, msg)
    }

    fn handle_update_add_htlc(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::UpdateAddHTLC,
    ) {
        self.ln_channel_manager
            .handle_update_add_htlc(their_node_id, msg)
    }

    fn handle_update_fulfill_htlc(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::UpdateFulfillHTLC,
    ) {
        self.ln_channel_manager
            .handle_update_fulfill_htlc(their_node_id, msg)
    }

    fn handle_update_fail_htlc(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::UpdateFailHTLC,
    ) {
        self.ln_channel_manager
            .handle_update_fail_htlc(their_node_id, msg)
    }

    fn handle_update_fail_malformed_htlc(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::UpdateFailMalformedHTLC,
    ) {
        self.ln_channel_manager
            .handle_update_fail_malformed_htlc(their_node_id, msg)
    }

    fn handle_commitment_signed(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::CommitmentSigned,
    ) {
        self.ln_channel_manager
            .handle_commitment_signed(their_node_id, msg)
    }

    fn handle_revoke_and_ack(&self, their_node_id: &PublicKey, msg: &RevokeAndACK) {
        self.ln_channel_manager
            .handle_revoke_and_ack(their_node_id, msg)
    }

    fn handle_update_fee(&self, their_node_id: &PublicKey, msg: &lightning::ln::msgs::UpdateFee) {
        self.ln_channel_manager
            .handle_update_fee(their_node_id, msg)
    }

    fn handle_announcement_signatures(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::AnnouncementSignatures,
    ) {
        self.ln_channel_manager
            .handle_announcement_signatures(their_node_id, msg)
    }

    fn peer_disconnected(&self, their_node_id: &PublicKey) {
        self.ln_channel_manager.peer_disconnected(their_node_id)
    }

    fn peer_connected(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::Init,
        inbound: bool,
    ) -> Result<(), ()> {
        self.ln_channel_manager
            .peer_connected(their_node_id, msg, inbound)
    }

    fn handle_channel_reestablish(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::ChannelReestablish,
    ) {
        if let Err(e) =
            self.on_channel_reestablish(their_node_id, msg.channel_id, msg.sub_channel_state)
        {
            error!(
                "Unexpected error {} processing reestablish for channel {:?}.",
                e, msg.channel_id
            );
        }
        self.ln_channel_manager
            .handle_channel_reestablish(their_node_id, msg)
    }

    fn handle_channel_update(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::ChannelUpdate,
    ) {
        self.ln_channel_manager
            .handle_channel_update(their_node_id, msg)
    }

    fn handle_error(&self, their_node_id: &PublicKey, msg: &lightning::ln::msgs::ErrorMessage) {
        self.ln_channel_manager.handle_error(their_node_id, msg)
    }

    fn provided_node_features(&self) -> lightning::ln::features::NodeFeatures {
        self.ln_channel_manager.provided_node_features()
    }

    fn provided_init_features(
        &self,
        their_node_id: &PublicKey,
    ) -> lightning::ln::features::InitFeatures {
        self.ln_channel_manager
            .provided_init_features(their_node_id)
    }

    fn handle_open_channel_v2(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::OpenChannelV2,
    ) {
        self.ln_channel_manager
            .handle_open_channel_v2(their_node_id, msg)
    }

    fn handle_accept_channel_v2(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::AcceptChannelV2,
    ) {
        self.ln_channel_manager
            .handle_accept_channel_v2(their_node_id, msg)
    }

    fn handle_tx_add_input(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::TxAddInput,
    ) {
        self.ln_channel_manager
            .handle_tx_add_input(their_node_id, msg)
    }

    fn handle_tx_add_output(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::TxAddOutput,
    ) {
        self.ln_channel_manager
            .handle_tx_add_output(their_node_id, msg)
    }

    fn handle_tx_remove_input(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::TxRemoveInput,
    ) {
        self.ln_channel_manager
            .handle_tx_remove_input(their_node_id, msg)
    }

    fn handle_tx_remove_output(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::TxRemoveOutput,
    ) {
        self.ln_channel_manager
            .handle_tx_remove_output(their_node_id, msg)
    }

    fn handle_tx_complete(&self, their_node_id: &PublicKey, msg: &lightning::ln::msgs::TxComplete) {
        self.ln_channel_manager
            .handle_tx_complete(their_node_id, msg)
    }

    fn handle_tx_signatures(
        &self,
        their_node_id: &PublicKey,
        msg: &lightning::ln::msgs::TxSignatures,
    ) {
        self.ln_channel_manager
            .handle_tx_signatures(their_node_id, msg)
    }

    fn handle_tx_init_rbf(&self, their_node_id: &PublicKey, msg: &lightning::ln::msgs::TxInitRbf) {
        self.ln_channel_manager
            .handle_tx_init_rbf(their_node_id, msg)
    }

    fn handle_tx_ack_rbf(&self, their_node_id: &PublicKey, msg: &lightning::ln::msgs::TxAckRbf) {
        self.ln_channel_manager
            .handle_tx_ack_rbf(their_node_id, msg)
    }

    fn handle_tx_abort(&self, their_node_id: &PublicKey, msg: &lightning::ln::msgs::TxAbort) {
        self.ln_channel_manager.handle_tx_abort(their_node_id, msg)
    }

    fn get_genesis_hashes(&self) -> Option<Vec<bitcoin::blockdata::constants::ChainHash>> {
        self.ln_channel_manager.get_genesis_hashes()
    }
}

impl<
        W: Deref,
        M: Deref,
        C: Deref,
        S: Deref,
        B: Deref,
        O: Deref,
        T: Deref,
        F: Deref,
        K: Deref,
        D: Deref<Target = Manager<W, B, S, O, T, F>>,
        CS: ChannelSigner,
        SP: Deref,
        LCS: LnDlcChannelSigner,
    > MessageSendEventsProvider for SubChannelManager<W, M, C, S, B, O, T, F, D, CS, SP, LCS, K>
where
    W::Target: Wallet,
    M::Target: LNChannelManager<K>,
    C::Target: LNChainMonitor,
    S::Target: Storage,
    B::Target: Blockchain,
    O::Target: Oracle,
    T::Target: Time,
    F::Target: FeeEstimator,
    SP::Target: LnDlcSignerProvider<LCS>,
    K::Target: SignerProvider,
{
    fn get_and_clear_pending_msg_events(&self) -> Vec<lightning::events::MessageSendEvent> {
        let mut msg_events = self.ln_channel_manager.get_and_clear_pending_msg_events();

        for event in msg_events.iter_mut() {
            if let lightning::events::MessageSendEvent::SendChannelReestablish { msg, .. } = event {
                match self.dlc_channel_manager.get_store().get_sub_channel(msg.channel_id) {
                            Err(e) => error!("Unexpected error {} trying to retrieve sub channel {:?} during sending of reestablish.", e, msg.channel_id),
                            Ok(None) => trace!("No sub channel with id {:?} to reestablish", msg.channel_id),
                            Ok(Some(c)) => {
                                let flag = c.get_reestablish_flag();
                                trace!("Inserting reestablish flag {:?} in reestablish for channel {:?}", flag, msg.channel_id);
                                msg.sub_channel_state = flag;
                            }
                        }
            }
        }

        msg_events
    }
}

fn validate_and_get_ln_values_per_party(
    channel_details: &ChannelDetails,
    own_collateral: u64,
    counter_collateral: u64,
    fee_rate: u64,
    is_offer: bool,
) -> Result<(u64, u64), Error> {
    let (offer_fees, accept_fees) = per_party_fee(fee_rate)?;
    let (own_fees, counter_fees) = if is_offer {
        (offer_fees, accept_fees)
    } else {
        (accept_fees, offer_fees)
    };

    let own_reserve_msat = channel_details.unspendable_punishment_reserve.unwrap_or(0) * 1000;
    let counter_reserve_msat = channel_details.counterparty.unspendable_punishment_reserve * 1000;

    let own_value_to_self_msat = (channel_details.outbound_capacity_msat + own_reserve_msat)
        .checked_sub((own_collateral + own_fees) * 1000)
        .ok_or_else(|| {
            Error::InvalidParameters(format!(
                "Not enough outbound capacity to establish given contract. Want {} but have {}",
                (own_collateral + own_fees) * 1000,
                channel_details.outbound_capacity_msat + own_reserve_msat
            ))
        })?;
    // TODO(tibo): find better ways to validate amounts + take into account increased fees.
    if own_value_to_self_msat < dlc::DUST_LIMIT * 1000 {
        return Err(Error::InvalidParameters(format!(
            "Not enough outbound capacity to establish given contract. Want {} but have {}",
            dlc::DUST_LIMIT * 1000,
            own_value_to_self_msat
        )));
    }

    let counter_value_to_self_msat = (channel_details.inbound_capacity_msat + counter_reserve_msat)
        .checked_sub((counter_collateral + counter_fees) * 1000)
        .ok_or_else(|| {
            Error::InvalidParameters(format!(
                "Not enough inbound capacity to establish given contract. Want {} but have {}",
                (counter_collateral + counter_fees) * 1000,
                channel_details.inbound_capacity_msat + counter_reserve_msat
            ))
        })?;
    // TODO(tibo): find better ways to validate amounts + take into account increased fees.
    if counter_value_to_self_msat < dlc::DUST_LIMIT * 1000 {
        return Err(Error::InvalidParameters(format!(
            "Not enough inbound capacity to establish given contract. Want {} but have {}",
            dlc::DUST_LIMIT * 1000,
            counter_value_to_self_msat
        )));
    }

    Ok((own_value_to_self_msat, counter_value_to_self_msat))
}

// Return fees for offer and accept parties (in that order). Offer pays 1 more
// if total fee is not even.
fn per_party_fee(fee_rate: u64) -> Result<(u64, u64), Error> {
    let total_fee = (dlc::channel::sub_channel::dlc_channel_and_split_fee(fee_rate)?
        + dlc::util::tx_weight_to_fee(LN_GLUE_TX_WEIGHT, fee_rate)?) as f64;
    Ok((
        (total_fee / 2.0).ceil() as u64,
        (total_fee / 2.0).floor() as u64,
    ))
}
