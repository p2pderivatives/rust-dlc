//! Description of contracts using an ordinal as part of the collateral.

use bitcoin::Transaction;
use dlc::{
    ord::{OrdPayout, SatPoint},
    RangePayout,
};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

use crate::error::Error;

use super::{enum_descriptor::EnumDescriptor, numerical_descriptor::NumericalDescriptor};

/// Descriptor for a contract involving an ordinal sat being traded.
#[derive(Clone, Debug)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct OrdDescriptor {
    /// The descriptor for the contract outcomes.
    pub outcome_descriptor: OrdOutcomeDescriptor,
    /// The original location of the ordinal within the UTXO set.
    pub ordinal_sat_point: SatPoint,
    /// The transaction where the UTXO containing the ordinal is located.
    pub ordinal_tx: Transaction,
    /// Whether it the offer party that should be refunded in case of a contract timeout.
    pub refund_offer: bool,
}

impl OrdDescriptor {
    pub(crate) fn get_ord_payouts(&self, total_collateral: u64) -> Result<Vec<OrdPayout>, Error> {
        match &self.outcome_descriptor {
            OrdOutcomeDescriptor::Enum(e) => {
                let payouts = e.descriptor.get_payouts();
                Ok(payouts
                    .iter()
                    .zip(&e.to_offer_payouts)
                    .map(|(x, y)| OrdPayout {
                        to_offer: *y,
                        offer: x.offer,
                        accept: x.accept,
                    })
                    .collect())
            }
            OrdOutcomeDescriptor::Numerical(n) => {
                let ord_range_payouts = n.get_ord_range_payouts(total_collateral)?;
                Ok(ord_range_payouts
                    .iter()
                    .map(|x| OrdPayout {
                        to_offer: x.to_offer,
                        offer: x.payout.payout.offer,
                        accept: x.payout.payout.accept,
                    })
                    .collect())
            }
        }
    }

    pub(crate) fn get_postage(&self) -> u64 {
        self.ordinal_tx.output[self.ordinal_sat_point.outpoint.vout as usize].value
    }
}

#[derive(Clone, Debug)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
/// Descriptor for the outcomes of a contract involving an ordinal.
pub enum OrdOutcomeDescriptor {
    /// Descriptor for an event that has enumerated outcomes.
    Enum(OrdEnumDescriptor),
    /// Descriptor for an event that has numerical outcomes.
    Numerical(OrdNumericalDescriptor),
}

#[derive(Clone, Debug)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
/// Descriptor for an event that has enumerated outcomes for contracts that involve an ordinal.
pub struct OrdEnumDescriptor {
    /// The description of the enumerated outcomes.
    pub descriptor: EnumDescriptor,
    /// The outcomes for which the ordinal is given to the offer party (one boolean for each
    /// possible outcome).
    pub to_offer_payouts: Vec<bool>,
}

#[derive(Clone, Debug)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
/// Descriptor for an event that has numerical outcomes for contracts that involve an ordinal.
pub struct OrdNumericalDescriptor {
    /// The descriptor of the numerical event.
    pub descriptor: NumericalDescriptor,
    /// The ranges for which the ordinal should be given to the offer party.
    pub to_offer_ranges: Vec<(u64, u64)>,
}

impl OrdNumericalDescriptor {
    /// The [`RangePayout`]s for the event. This will likely differ from the one generated by the
    /// underlying [`NumericalDescriptor`] if the `to_offer_ranges` do not overlap with the ranges
    /// of the numerical event.
    pub fn get_range_payouts(&self, total_collateral: u64) -> Result<Vec<RangePayout>, Error> {
        let base = self.descriptor.get_range_payouts(total_collateral)?;

        Ok(build_ord_range_payouts(&base, &self.to_offer_ranges)
            .into_iter()
            .map(|x| x.payout)
            .collect())
    }

    /// The payouts and ordinal assignments for the ranges that cover the event domain.
    fn get_ord_range_payouts(&self, total_collateral: u64) -> Result<Vec<OrdRangePayout>, Error> {
        let base = self.descriptor.get_range_payouts(total_collateral)?;

        Ok(build_ord_range_payouts(&base, &self.to_offer_ranges))
    }
}

fn build_ord_range_payouts(
    base: &[RangePayout],
    to_offer_ranges: &[(u64, u64)],
) -> Vec<OrdRangePayout> {
    let mut res = Vec::new();
    let mut start = 0;
    let mut cur_offer_range_index = 0;
    let mut cur_range_payout_index = 0;

    while cur_offer_range_index < to_offer_ranges.len() || cur_range_payout_index < base.len() {
        let (start1, end1) = to_offer_ranges
            .get(cur_offer_range_index)
            .map_or((usize::MIN, usize::MAX), |x| (x.0 as usize, x.1 as usize));
        let (start2, end2) = base
            .get(cur_range_payout_index)
            .map_or((usize::MIN, usize::MAX), |x| {
                (x.start, x.start + x.count - 1)
            });
        start = usize::min(usize::max(start, start1), usize::max(start, start2));
        let n_start = usize::max(start1, start2).saturating_sub(1);
        let end = if n_start >= start && n_start < usize::min(end1, end2) {
            n_start
        } else if end1 < end2 {
            cur_offer_range_index += 1;
            end1
        } else if end1 == end2 {
            cur_range_payout_index += 1;
            cur_offer_range_index += 1;
            end2
        } else {
            cur_range_payout_index += 1;
            end2
        };
        res.push(OrdRangePayout {
            payout: RangePayout {
                start,
                count: end - start + 1,
                payout: base
                    .get(cur_range_payout_index)
                    .map_or(base.last().unwrap().payout, |x| x.payout),
            },
            to_offer: to_offer_ranges
                .iter()
                .any(|x| start as u64 >= x.0 && end as u64 <= x.1),
        });
        start = end + 1;
    }

    res
}

#[derive(Debug, PartialEq, Eq)]
struct OrdRangePayout {
    payout: RangePayout,
    to_offer: bool,
}

#[cfg(test)]
mod tests {
    use bitcoin::{OutPoint, PackedLockTime, Transaction};
    use dlc::{
        ord::{OrdPayout, SatPoint},
        EnumerationPayout, Payout, RangePayout,
    };

    use crate::contract::enum_descriptor::EnumDescriptor;

    use super::{build_ord_range_payouts, OrdDescriptor, OrdOutcomeDescriptor, OrdRangePayout};

    #[test]
    fn build_range_payouts_test() {
        let payout = (0..3)
            .map(|_| Payout {
                offer: 10,
                accept: 0,
            })
            .collect::<Vec<_>>();
        let base = vec![
            RangePayout {
                start: 0,
                count: 11,
                payout: payout[0],
            },
            RangePayout {
                start: 11,
                count: 9,
                payout: payout[1],
            },
            RangePayout {
                start: 20,
                count: 11,
                payout: payout[2],
            },
        ];

        let to_offer_ranges = vec![(5, 8), (10, 12), (14, 16), (20, 30)];

        let expected = vec![
            OrdRangePayout {
                payout: RangePayout {
                    start: 0,
                    count: 5,
                    payout: payout[0],
                },
                to_offer: false,
            },
            OrdRangePayout {
                payout: RangePayout {
                    start: 5,
                    count: 4,
                    payout: payout[0],
                },
                to_offer: true,
            },
            OrdRangePayout {
                to_offer: false,
                payout: RangePayout {
                    start: 9,
                    count: 1,
                    payout: payout[0],
                },
            },
            OrdRangePayout {
                to_offer: true,
                payout: RangePayout {
                    start: 10,
                    count: 1,
                    payout: payout[0],
                },
            },
            OrdRangePayout {
                to_offer: true,
                payout: RangePayout {
                    start: 11,
                    count: 2,
                    payout: payout[1],
                },
            },
            OrdRangePayout {
                to_offer: false,
                payout: RangePayout {
                    start: 13,
                    count: 1,
                    payout: payout[1],
                },
            },
            OrdRangePayout {
                to_offer: true,
                payout: RangePayout {
                    start: 14,
                    count: 3,
                    payout: payout[1],
                },
            },
            OrdRangePayout {
                to_offer: false,
                payout: RangePayout {
                    start: 17,
                    count: 3,
                    payout: payout[1],
                },
            },
            OrdRangePayout {
                to_offer: true,
                payout: RangePayout {
                    start: 20,
                    count: 11,
                    payout: payout[2],
                },
            },
        ];
        let actual = build_ord_range_payouts(&base, &to_offer_ranges);

        assert_eq!(expected, actual);
    }

    #[test]
    fn get_ord_payouts_enum_test() {
        let descriptor = OrdDescriptor {
            outcome_descriptor: OrdOutcomeDescriptor::Enum(super::OrdEnumDescriptor {
                descriptor: EnumDescriptor {
                    outcome_payouts: vec![
                        EnumerationPayout {
                            outcome: "A".to_string(),
                            payout: Payout {
                                offer: 10,
                                accept: 0,
                            },
                        },
                        EnumerationPayout {
                            outcome: "B".to_string(),
                            payout: Payout {
                                offer: 9,
                                accept: 1,
                            },
                        },
                        EnumerationPayout {
                            outcome: "C".to_string(),
                            payout: Payout {
                                offer: 8,
                                accept: 2,
                            },
                        },
                    ],
                },
                to_offer_payouts: vec![true, true, false],
            }),
            ordinal_sat_point: SatPoint {
                outpoint: OutPoint::default(),
                offset: 0,
            },
            ordinal_tx: Transaction {
                version: 2,
                lock_time: PackedLockTime::ZERO,
                input: Vec::new(),
                output: Vec::new(),
            },
            refund_offer: true,
        };

        let expected = vec![
            OrdPayout {
                to_offer: true,
                offer: 10,
                accept: 0,
            },
            OrdPayout {
                to_offer: true,
                offer: 9,
                accept: 1,
            },
            OrdPayout {
                to_offer: false,
                offer: 8,
                accept: 2,
            },
        ];

        let actual = descriptor
            .get_ord_payouts(10)
            .expect("to be able to compute the ord payouts");

        assert_eq!(expected, actual);
    }
}
